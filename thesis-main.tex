\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}

\school{\unibo}
\programme{Corso di Laurea Triennale in Ingegneria e Scienze Informatiche}
\title{Decentralized Messaging System with Aggregate Computing}
\author{Luca Marchi}
\date{\today}
\subject{Programmazione ad Oggetti}
\supervisor{Prof. Pianini Danilo}
\cosupervisor{Dott.ssa Cortecchia Angela}
% \morecosupervisor{Dott. CoSupervisor 2}
\session{II}
\academicyear{2024-2025}

% Definition of acronyms
\acrodef{IoT}{Internet of Thing}
\acrodef{vm}[VM]{Virtual Machine}


\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece


\begin{abstract}	

\end{abstract}

\begin{dedication} % this is optional
To my family.
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------
\section{Context}
In a world where Internet of Things (\ac{IoT}) devices are becoming increasingly prevalent,
    the need for efficient and reliable communication systems is paramount
    \begin{figure}
        \centering
        \fbox{\includegraphics[width=.8\linewidth]{figures/iot-devices.png}}
        \caption{A variety of IoT devices communicating with each other in a real world scenario.}
        \label{fig:iot-devices}
    \end{figure}
    \Cref{fig:iot-devices}.
    The interactions between neighboring devices play a crucial role in enabling seamless data exchange and coordination,
    so there is the need to design networks with infrastructures that support scalability, adaptability and reusability \cite{beal2015aggregate}.
    In the past, it was reasonable to use a programming model that focused on the
    individual computing device, and its relationship with one or more users.
    However, as systems have grown in scale and complexity with the number of computing devices rising,
    this method has become inadequate.
    Traditional network architectures, rely heavily on centralized
    infrastructures, making them unsuitable for scenarios such as disaster recovery or interactions with neighboring devices.
    The computational model of \textit{aggregate computing} provides a promising
    approach to address these challenges by enabling decentralized and self-organizing systems \cite{viroli2019aggregate}.
    Building on this concept, this thesis explores how aggregate programming
    can support a proximity and decentralized messaging system in a network.



\subsection{Aggregate Programming}
\textbf{Aggregate programming} is a distributed systems paradigm that simplifies programming large networks of devices by focusing on the global, system-level behavior rather than the individual behavior of each device.
It shifts the abstraction to view the network as an aggregate, an agglomeration of nodes that collectively exhibit certain behaviors.
This model is particularly well-suited for scenarios where devices need to coordinate and collaborate based on local interactions, such as in \ac{IoT} applications.
As discussed in distributed field programming \cite{viroli2019aggregate}, there are principles to follow when designing large-scale systems:
\begin{itemize}
    \item The mechanisms ensuring robust coordination should operate transparently in the background, so that programmers don’t need to manage them directly.
    \item The composition of modules and subsystems should be simple and predictable, allowing developers to clearly understand the consequences of combining components.
    \item Large-scale distributed systems often consist of multiple heterogeneous subsystems, each of which may require different coordination strategies depending on the region or context in time.
\end{itemize}
Aggregate programming aims to overcome these challenges through three fundamental principles:
\begin{enumerate}
    \item The computational target is conceived as a region of the environment, with the underlying device-level details abstracted away, potentially even modeled as a continuous spatial domain.
    \item The program logic is expressed as the manipulation of data structures that extend spatially and temporally across that region.
    \item These computations are executed locally by individual devices within the region, which coordinate through resilient mechanisms and proximity-based interactions.
\end{enumerate}
The foundation of this paradigm lies on \textit{field calculus} \cite{beal2015aggregate},
a core set of constructs modeling device behavior and interaction. These essential features are captured
in a tiny universal language suitable for mathematical analysis.
The concept of \textbf{field} plays a central role in this context and originates from physics, where it is defined as a function mapping every point in a space–time domain to a scalar value.
According to \cite{viroli2019aggregate}, the \textit{field value} $\phi$ is a function
\[
\phi : D \rightarrow L
\]
that maps each device $\delta$ in the domain $D$ to a local value $\ell$ in the range $L$.
This value can change in time with a \textit{field evolution} that maps each point in time to a field value.
\Cref{fig:layers-AP} shows how aggregate programming abstracts the complexity of the underlying distributed network and its
 coordination challenges through a sequence of hierarchical abstraction layers.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/layers-AP.png}}
    \caption{Layered structure of aggregate programming, illustrating the abstraction at each level.}
    \label{fig:layers-AP}
\end{figure}

The messaging system developed in this thesis was implemented using \textit{Collektive} \cite{amslaurea31080}, an open-source framework for aggregate computing written in Kotlin. 
This framework provides the developer-facing APIs (shown in \Cref{fig:layers-AP}) used to define and execute aggregate applications.
\subsection{Collektive}
Collektive 


\chapter{State of the art}


\chapter{Contribution}

You may also put some code snippet (which is NOT float by default), eg: \cref{lst:random-code}.

\lstinputlisting[float,language=Java,label={lst:random-code}]{listings/HelloWorld.java}

\section{Fancy formulas here}

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter


\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}
