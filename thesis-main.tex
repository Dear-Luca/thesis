\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acro}

\school{\unibo}
\programme{Corso di Laurea Triennale in Ingegneria e Scienze Informatiche}
\title{Multi-platform distributed systems with aggregate computing in Kotlin: the case of proximity messaging}
\author{Luca Marchi}
\date{\today}
\subject{Programmazione ad Oggetti}
\supervisor{Prof. Pianini Danilo}
\cosupervisor{Dott.ssa Cortecchia Angela}

\session{II}
\academicyear{2024-2025}

\acsetup{first-style=long-short}
\DeclareAcronym{IoT}{
  short = IoT,
  long  = Internet of Things
}
\DeclareAcronym{KMP}{
  short = KMP,
  long  = Kotlin Multiplatform
}
\DeclareAcronym{DSL}{
    short = DSL,
    long  = Domain Specific Language
}


\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	

\end{abstract}

\begin{dedication} % this is optional
To my family.
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------
\section{Context}
In a world where \ac{IoT} devices are becoming increasingly prevalent,
    the need for efficient and reliable communication systems is paramount
    \begin{figure}
        \centering
        \fbox{\includegraphics[width=.8\linewidth]{figures/iot-devices.png}}
        \caption{A variety of \ac{IoT} devices communicating with each other in a real world scenario.}
        \label{fig:iot-devices}
    \end{figure}
    (\Cref{fig:iot-devices}).

    The interactions between neighboring devices play a crucial role in enabling seamless data exchange and coordination,
    so there is the need to design networks with infrastructures that support scalability, adaptability and reusability \cite{beal2015aggregate}.
    In the past, it was reasonable to use a programming model that focused on the
    individual computing device, and its relationship with one or more users.
    However, as systems have grown in scale and complexity with the number of computing devices rising,
    this method has become inadequate.

    Traditional network architectures, rely heavily on centralized
    infrastructures, making them unsuitable for scenarios such as disaster recovery or interactions with neighboring devices.
    The computational model of \textit{aggregate computing} provides a promising
    approach to address these challenges by enabling decentralized and self-organizing systems \cite{viroli2019aggregate}.
    
    Building on this concept, this thesis explores how aggregate programming
    can support a proximity and decentralized messaging system in a network.



\subsection{Aggregate Programming}
\textbf{Aggregate Programming} is a distributed systems paradigm that simplifies programming large networks of devices by focusing on the global, system-level behavior rather than the individual behavior of each device.
It shifts the abstraction to view the network as an aggregate, an agglomeration of nodes that collectively exhibit certain behaviors.
This model is particularly well-suited for scenarios where devices need to coordinate and collaborate based on local interactions, such as in \ac{IoT} applications.

As discussed in distributed field programming \cite{viroli2019aggregate}, there are principles to follow when designing large-scale systems:
\begin{itemize}
    \item The mechanisms ensuring robust coordination should operate transparently in the background, so that programmers don’t need to manage them directly.
    \item The composition of modules and subsystems should be simple and predictable, allowing developers to clearly understand the consequences of combining components.
    \item Large-scale distributed systems often consist of multiple heterogeneous subsystems, each of which may require different coordination strategies depending on the region or context in time.
\end{itemize}
Aggregate programming aims to overcome these challenges through three fundamental principles:
\begin{enumerate}
    \item The computational target is conceived as a region of the environment, with the underlying device-level details abstracted away, potentially even modeled as a continuous spatial domain.
    \item The program logic is expressed as the manipulation of data structures that extend spatially and temporally across that region.
    \item These computations are executed locally by individual devices within the region, which coordinate through resilient mechanisms and proximity-based interactions.
\end{enumerate}
The foundation of this paradigm lies on \textit{field calculus} \cite{beal2015aggregate},
a core set of constructs modeling device behavior and interaction. These essential features are captured
in a tiny universal language suitable for mathematical analysis.
The concept of \textbf{field} plays a central role in this context and originates from physics, where it is defined as a function mapping every point in a space–time domain to a scalar value.

According to \cite{viroli2019aggregate}, the \textit{field value} $\phi$ is a function
\[
\phi : D \rightarrow L
\]
that maps each device $\delta$ in the domain $D$ to a local value $\ell$ in the range $L$.
This value can change in time with a \textit{field evolution} that maps each point in time to a field value.
\Cref{fig:layers-AP} shows how aggregate programming abstracts the complexity of the underlying distributed network and its
 coordination challenges through a sequence of hierarchical abstraction layers.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/layers-AP.png}}
    \caption{Layered structure of aggregate programming, illustrating the abstraction at each level.}
    \label{fig:layers-AP}
\end{figure}

The messaging system developed in this thesis was implemented using \textit{Collektive} \cite{amslaurea31080}, 
an open-source framework designed to simplify the development of distributed systems through the principles of Aggregate Programming. 
Collektive provides developer-facing APIs (as in \Cref{fig:layers-AP}) used to define and execute aggregate applications.
\subsection{Collektive}
Collektive is a framework with the purpose of simplifying the definition of Aggregate Computing systems.
To achieve this, Collektive adopts the Field Calculus model, providing an intuitive way to define aggregate
behavior without low-level coding. Built with \ac{KMP}, it can be executed seamlessly on different targets.
Moreover, a compiler plugin was introduced to support function alignment, automatically annotating aligned functions to ensure consistent coordination among nodes
\cite{amslaurea31080}.

The main features of this framework can be summarized as follows \cite{collektive_docs}:
\begin{itemize}
\item \textbf{High-Level Abstraction}: Collektive streamlines the development of distributed behaviors by enabling developers to define coordination logic succinctly, without explicitly handling individual device states.
\item \textbf{Declarative Programming}: The framework adopts a declarative paradigm, allowing developers to specify the desired system outcomes, while the underlying runtime manages the execution details.
\item \textbf{Dynamic Adaptation}: Applications developed with Collektive can automatically adapt to network variations and external inputs, maintaining robustness in dynamic and unpredictable environments.
\end{itemize}

It provides a minimal \ac{DSL} where the developer can specify the
collective behaviour of a network of devices and the devices can directly communicate with each other and execute the same program.

\section{Motivations}
In this section motivations for implementing a decentralized proximity-based messaging system will be illustrated.

In recent years, the proliferation of \ac{IoT} and mobile devices has increased the need for local communication systems capable of operating even without stable network infrastructure. Centralized architectures, although efficient in connected environments, fail to guarantee reliability and resilience in dynamic or disconnected scenarios.
As devices are becoming pervasive and ubiquitous, new models are required to enable coordination and information exchange without relying on fixed infrastructures.
This need motivates the exploration of decentralized and distributed approaches, which can operate robustly in dynamic and connectivity-limited environments.

% Describe what problem exists and why it’s challenging.
% Focus on the technical or conceptual gap your thesis addresses.

\subsection{Problem statement}
Traditional messaging systems and architectures often rely heavily on centralized servers and infrastructures, which are 
unsuitable and vulnerable for scenarios where connectivity is not guaranteed. 
These situations include \textbf{disaster recovery}, the process for restoring an organization's network infrastructure and operations after a disruptive event, such as a natural disaster, cyberattack, or system failure.

In such environments there are several vulnerabilities and challenges to consider:
\begin{itemize}
    \item \textbf{Single point of failure}: Centralized systems are vulnerable to failures of the authority that makes decisions. This can lead to widespread service disruption and outages.
    \item \textbf{Scalability issues}: As the number of devices increases, centralized systems may struggle to manage the growing volume of data and communication, leading to bottlenecks and delayed responses.
    \item \textbf{Limited resilience}: Centralized architectures often lack the redundancy and fault tolerance needed to maintain functionality in the face of network disruptions or device failures.
\end{itemize}
The networks that need to overcome the issues above can benefit from Aggregate Computing principles, which provides
a distributed architecture where the nodes can directly communicate with the neighbors.
% Give practical examples where your system or research could apply — 
% this grounds your thesis in reality and shows relevance.
\subsection{Real world use cases}


% List what your thesis aims to achieve — clearly, concretely, and in your own scope.
% This section connects the problem and use cases to your proposed solution.

\subsection{Goal}
\chapter{State of the art}


\chapter{Contribution}

You may also put some code snippet (which is NOT float by default), eg: \cref{lst:random-code}.

\lstinputlisting[float,language=Java,label={lst:random-code}]{listings/HelloWorld.java}

\section{Fancy formulas here}

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter


\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}
