\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acro}
\usepackage{booktabs}

\school{\unibo}
\programme{Corso di Laurea Triennale in Ingegneria e Scienze Informatiche}
\title{Multi-platform distributed systems with aggregate computing in Kotlin: the case of proximity messaging}
\author{Luca Marchi}
\date{\today}
\subject{Programmazione ad Oggetti}
\supervisor{Prof. Pianini Danilo}
\cosupervisor{Dott.ssa Cortecchia Angela}

\session{II}
\academicyear{2024-2025}

\acsetup{first-style=long-short}
\DeclareAcronym{IoT}{
  short = IoT,
  long  = Internet of Things
}
\DeclareAcronym{KMP}{
  short = KMP,
  long  = Kotlin Multiplatform
}
\DeclareAcronym{DSL}{
    short = DSL,
    long  = Domain Specific Language
}

\DeclareAcronym{UI}{
    short = UI,
    long  = User Interface
}

\DeclareAcronym{GUI}{
    short = GUI,
    long  = Graphical User Interface
}

\DeclareAcronym{P2P}{
    short = P2P,
    long  = Peer-to-Peer
}

\DeclareAcronym{BLE}{
    short = BLE,
    long  = Bluetooth Low Energy
}

\DeclareAcronym{PAN}{
    short = PAN,
    long  = Personal Area Network
}

\DeclareAcronym{MQTT}{
    short = MQTT,
    long  = Message Queuing Telemetry Transport
}

\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	

\end{abstract}

\begin{dedication} % this is optional
To my family.
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------
\section{Context}
In a world where \ac{IoT} devices are becoming increasingly prevalent,
    the need for efficient and reliable communication systems is paramount
    \begin{figure}
        \centering
        \fbox{\includegraphics[width=.8\linewidth]{figures/iot-devices.png}}
        \caption{Our world is increasingly populated with a wide range of computing devices, embedded in our environment and with many opportunities for local and even location-independent interactions on fixed network infrastructures~\protect\cite{beal2015aggregate}.}
        \label{fig:iot-devices}
    \end{figure}
    (\Cref{fig:iot-devices}).

    The interactions between neighboring devices play a crucial role in enabling seamless data exchange and coordination,
    so there is the need to design networks with infrastructures that support scalability, adaptability and reusability \cite{beal2015aggregate}.
    In the past, it was reasonable to use a programming model that focused on the
    individual computing device, and its relationship with one or more users.
    However, as systems have grown in scale and complexity with the number of computing devices rising,
    this method has become inadequate.

    Traditional network architectures, rely heavily on centralized
    infrastructures, making them unsuitable for scenarios such as disaster recovery or interactions with neighboring devices.
    The computational model of \textit{aggregate computing} provides a promising
    approach to address these challenges by enabling decentralized and self-organizing systems \cite{viroli2019aggregate}.
    
    Building on this concept, this thesis explores how aggregate programming
    can support a proximity and decentralized messaging system in a network.



\subsection{Aggregate Programming}
\textbf{Aggregate Programming} is a distributed systems paradigm that simplifies programming large networks of devices by focusing on the global, system-level behavior rather than the individual behavior of each device.
It shifts the abstraction to view the network as an aggregate, an agglomeration of nodes that collectively exhibit certain behaviors.
This model is particularly well-suited for scenarios where devices need to coordinate and collaborate based on local interactions, such as in \ac{IoT} applications.

As discussed in distributed field programming \cite{viroli2019aggregate}, there are principles to follow when designing large-scale systems:
\begin{itemize}
    \item The mechanisms ensuring robust coordination should operate transparently in the background, so that programmers don’t need to manage them directly.
    \item The composition of modules and subsystems should be simple and predictable, allowing developers to clearly understand the consequences of combining components.
    \item Large-scale distributed systems often consist of multiple heterogeneous subsystems, each of which may require different coordination strategies depending on the region or context in time.
\end{itemize}
Aggregate programming aims to overcome these challenges through three fundamental principles:
\begin{enumerate}
    \item The computational target is conceived as a region of the environment, with the underlying device-level details abstracted away, potentially even modeled as a continuous spatial domain.
    \item The program logic is expressed as the manipulation of data structures that extend spatially and temporally across that region.
    \item These computations are executed locally by individual devices within the region, which coordinate through resilient mechanisms and proximity-based interactions.
\end{enumerate}
The foundation of this paradigm lies in \textit{field calculus} \cite{beal2015aggregate},
a core set of constructs modeling device behavior and interaction. These essential features are captured
in a tiny universal language suitable for mathematical analysis.
The concept of \textbf{field} plays a central role in this context and originates from physics, where it is defined as a function mapping every point in a space–time domain to a scalar value.

According to \cite{viroli2019aggregate}, the \textit{field value} $\phi$ is a function
\[
\phi : D \rightarrow L
\]
that maps each device $\delta$ in the domain $D$ to a local value $\ell$ in the range $L$.
This value can change in time with a \textit{field evolution} that maps each point in time to a field value.
\Cref{fig:layers-AP} shows how aggregate programming abstracts the complexity of the underlying distributed network and its
 coordination challenges through a sequence of hierarchical abstraction layers.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/layers-AP.png}}
    \caption{Layered structure of aggregate programming, illustrating the abstraction at each level~\protect\cite{beal2015aggregate}.}
    \label{fig:layers-AP}
\end{figure}

The messaging system developed in this thesis was implemented using \textit{Collektive} \cite{amslaurea31080}, 
an open-source framework designed to simplify the development of distributed systems through the principles of Aggregate Programming. 
Collektive provides developer-facing APIs (as in \Cref{fig:layers-AP}) used to define and execute aggregate applications.
\subsection{Collektive}
Collektive is a framework with the purpose of simplifying the definition of Aggregate Computing systems.
To achieve this, Collektive adopts the Field Calculus model, providing an intuitive way to define aggregate
behavior without low-level coding. Built with \ac{KMP}, it can be executed seamlessly on different targets.
Moreover, a compiler plugin was introduced to support function alignment, automatically annotating aligned functions to ensure consistent coordination among nodes
\cite{amslaurea31080}.

The main features of this framework can be summarized as follows \cite{collektive_docs}:
\begin{itemize}
\item \textbf{High-Level Abstraction}: Collektive streamlines the development of distributed behaviors by enabling developers to define coordination logic succinctly, without explicitly handling individual device states.
\item \textbf{Declarative Programming}: The framework adopts a declarative paradigm, allowing developers to specify the desired system outcomes, while the underlying runtime manages the execution details.
\item \textbf{Dynamic Adaptation}: Applications developed with Collektive can automatically adapt to network variations and external inputs, maintaining robustness in dynamic and unpredictable environments.
\end{itemize}

It provides a minimal \ac{DSL} where the developer can specify the
collective behaviour of a network of devices and the devices can directly communicate with each other and execute the same program.

\section{Motivations}
In this section motivations for implementing a decentralized proximity-based messaging system will be illustrated.

In recent years, the proliferation of \ac{IoT} and mobile devices has increased the need for local communication systems capable of operating even without stable network infrastructure. Centralized architectures, although efficient in connected environments, fail to guarantee reliability and resilience in dynamic or disconnected scenarios.
As devices are becoming pervasive and ubiquitous, new models are required to enable coordination and information exchange without relying on fixed infrastructures.
This need motivates the exploration of decentralized and distributed approaches, which can operate robustly in dynamic and connectivity-limited environments.

% Describe what problem exists and why it’s challenging.
% Focus on the technical or conceptual gap your thesis addresses.

\subsection{Problem statement}
Traditional messaging systems and architectures often rely heavily on centralized servers and infrastructures, which are 
unsuitable and vulnerable for scenarios where connectivity is not guaranteed. 
These situations include \textbf{disaster recovery}, the process for restoring an organization's network infrastructure and operations after a disruptive event, such as a natural disaster, cyberattack, or system failure.

In such environments there are several vulnerabilities and challenges to consider:
\begin{itemize}
    \item \textbf{Single point of failure}: Centralized systems are vulnerable to failures of the authority that makes decisions. This can lead to widespread service disruption and outages.
    \item \textbf{Scalability issues}: As the number of devices increases, centralized systems may struggle to manage the growing volume of data and communication, leading to bottlenecks and delayed responses.
    \item \textbf{Limited resilience}: Centralized architectures often lack the redundancy and fault tolerance needed to maintain functionality in the face of network disruptions or device failures.
\end{itemize}
The networks that need to overcome the issues above can benefit from Aggregate Computing principles, which provides
a distributed architecture where the nodes can directly communicate with the neighbors.

% Give practical examples where your system or research could apply — 
% this grounds your thesis in reality and shows relevance.
\subsection{Real world use cases}
As mentioned in the previous sections, there are several scenarios where a decentralized proximity-based messaging system can be particularly beneficial.

The main use case of such system is in emergency situations. 
When natural disasters, or infrastructure failures occur, cellular networks and Internet connections often go down, making it difficult for people to communicate and coordinate rescue efforts.  
Nearby devices can form ad-hoc Bluetooth or Wi-Fi Direct networks, allowing users in the same area to propagate and share messages without relying on centralized servers.

This architecture can also be useful in large \ac{IoT} networks like sensors systems or drones swarms, operating in remote areas and with the need to communicate without continuous Internet access.

The system's decentralized nature fits perfectly for:
\begin{itemize}
    \item Exchanging local environmental data (temperature, humidity, motion).
    \item Maintaining distributed consensus or context awareness among nearby nodes.
    \item Avoiding single points of failure.
\end{itemize}
A practical example includes a network of environmental sensors deployed in a forest to monitor conditions and detect wildfires (\Cref{fig:use-cases}), or sensors in a smart agriculture field that share humidity data to coordinate irrigation locally.
\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/The-proposed-architecture-for-forest-fire-detection.png}}
    \caption{Real-world use case of a decentralized proximity-based messaging application built on Aggregate Computing principles.
     In this scenario, sensors located near the fire detect the event and propagate an alert message to neighboring nodes within the network~\protect\cite{inproceedings}.}
    \label{fig:use-cases}
\end{figure}
% List what your thesis aims to achieve — clearly, concretely, and in your own scope.
% This section connects the problem and use cases to your proposed solution.

\subsection{Goal}
This thesis can be divided into two main goals:
\begin{enumerate}
    \item \label{goal:algorithm} \textbf{Messaging algorithm}: The first goal is to design and implement a decentralized, proximity-based messaging algorithm grounded in the principles of aggregate computing. 
    The network operates in a fully distributed manner, without any central server managing message exchange. 
    Each node acts autonomously, coordinating with its neighbors through local interactions and collectively achieving self-organization, thereby eliminating single points of failure. 
    Communication is proximity-based: devices can only interact with nearby nodes, and messages are propagated progressively across the network, layer by layer. 
    The algorithm must also handle dynamic network topologies, where devices can join or leave the network at any time, ensuring robustness and adaptability. 
    Message sources can define both an expiration time and a maximum propagation distance, enabling controlled diffusion and limiting unnecessary communication overhead. 
    The system is implemented using the \textit{Collektive} framework \cite{amslaurea31080}, leveraging \ac{KMP} to ensure cross-platform compatibility across different targets including 
    JVM, Javascript (browser), Android, iOS, and native versions (for Windows, MacOS, and Linux, both for x86 and ARM CPUs).
    \item \label{goal:application} \textbf{Mobile application}: The second goal is to develop a multiplatform mobile application using \ac{KMP}. 
    This application leverages the messaging algorithm as a core library to send and receive messages from devices in the network. 
    The app must support both Android and iOS platforms providing a simple, user-friendly interface.
    The \ac{UI} allows users to compose messages, configure parameters (expiration time and propagation distance), and view received messages in real-time.
    Another feature is the anonymization of the users, there is not any registration or login system, the users are completely anonymous. Anybody can use the app without providing any personal information.

\end{enumerate}

\section{State of Art}
In this section, it will be presented the state of the art in the field of decentralized communication systems.
 The focus will be on the main existing systems, aggregate computing frameworks, and lightweight communication protocols.
\subsection{Existing systems}
Several communication technologies and systems have been developed over the years to facilitate decentralized data exchange among devices.
The software that has spread the most and gained significant attention includes: \textit{Briar}, \textit{Bridgefy}, \textit{FireChat}.
\subsubsection{Briar}
\textbf{Briar} \cite{briar} is an open-source \ac{P2P} messaging platform designed for secure,
 resilient communication without centralized servers.
It supports multiple transport methods including Bluetooth, Wi-Fi and Tor, with all communication end-to-end encrypted.
Briar provide a mailbox system \textit{Briar Mailbox} that lets the users receive encrypted messages from their contacts while Briar is offline. Next time Briar comes online it will automatically fetch the messages from the Mailbox.
The primary target audience includes activists, journalists, and civil society members who require secure communication in restricted or infrastructure-limited environments.

A notable feature is the ability to install Briar on an Android device directly from another device that already has it installed, facilitating deployment in disconnected scenarios.
Nowadays the application is available only for Android devices, with no official iOS version.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/briar.png}}
    \caption{Diagram illustrating how Briar supports private messaging, public forums, and blogs through multiple transport methods such as Bluetooth, Wi-Fi, and the Internet. \protect\cite{briar}.}
    \label{fig:briar-architecture}
\end{figure}

\subsubsection{Bridgefy}
\textbf{Bridgefy} \cite{bridgefy} is a mobile messaging application that enables offline communication through Bluetooth mesh networking technology.

The platform allows smartphones to connect directly with nearby devices, creating a decentralized mesh network that can relay messages across multiple hops without requiring Internet connectivity.
Originally designed for emergency situations and large gatherings where cellular networks become congested, Bridgefy has been deployed in various crisis scenarios including natural disasters and political protests.

Messages are automatically routed through intermediate devices, extending the effective communication range beyond direct Bluetooth connectivity (typically 100 meters).
Bridgefy uses encryption protocols to secure message transmission; this capability was not available in the app's initial versions.

The service operates on both Android and iOS devices, with a user-friendly interface designed for rapid adoption during emergency situations.
One limitation is the reliance on device density: the mesh network requires sufficient nearby users to establish reliable multi-hop communication paths.


\subsubsection{FireChat}
\textbf{Firechat} was the first popular example of a messaging application that used mesh network topology to communicate between users.

\cite{7937749} FireChat relays messages from one device to another through each user's WiFi or Bluetooth radios, thereby creating a “mesh” of phones receiving and relaying messages even when each message is not viewable on every device (\Cref{fig:firechat-architecture}).
 This method of communication eliminates the need for centralized communication channels such as cellphone towers that every transmission must pass through.
While this system is beneficial in overcrowded networks, it eliminates the possibility of controlling or monitoring the network at one point.

Although not originally intended for this purpose, FireChat was widely adopted during civil protests.
 The application gained popularity in Iraq in 2014, when government restrictions limited Internet access, and later during the 2014 Hong Kong protests (known as the Umbrella Revolution)

Nowadays Firechat is discontinued and no longer available on app stores, the official website is also offline.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/bluetooth-mesh.png}}
    \caption{FireChat's mesh networking architecture, where messages are relayed through nearby devices using WiFi and Bluetooth, enabling communication without centralized infrastructure.}
    \label{fig:firechat-architecture}
\end{figure}

\subsubsection{Final considerations} Those three illustrated applications have more or less the same purpose of providing a decentralized approach to messaging.
\textit{Briar} stands out for its strong emphasis on security and privacy, making it suitable for users in sensitive situations. 
\textit{Bridgefy} is the most user-friendly and practical, focused on connecting users in emergency scenarios; encryption was included in later versions.
\textit{FireChat} was the pioneering first popular example, but now outdated and discontinued. It inspired newer applications.

These applications demonstrate the feasibility of decentralized communication, they rely on predefined routing or broadcasting protocols.
 None of them incorporate \textit{spatial awareness} or \textit{self-organizing behavior}, features that are naturally modeled through \textit{aggregate computing}.

\subsection{Aggregate computing frameworks}
There are several frameworks and libraries that facilitate the development of aggregate computing applications, 
implementing the principles of field calculus and providing abstractions for defining collective behaviors.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/scafi.png}}
    \caption{High-level architecture of the ScaFi framework, illustrating its components ~\protect\cite{CASADEI2022101248}.}
    \label{fig:scafi-architecture}
\end{figure}
Some of the most notable ones include:
\begin{itemize}
    \item \textbf{ScaFi} (Scala Field) is a framework written in Scala for aggregate computing \cite{CASADEI2022101248}. 
    It provides a \ac{DSL} and API modules for writing, testing, and running aggregate programs, the high-level architecture of ScaFi is depicted in \Cref{fig:scafi-architecture}.
    \textit{ScaFi} also includes a simulation environment with a \ac{GUI}, integrated with the Alchemist simulator \cite{10.1007/978-3-030-78198-9_10}.
    
    The main applications are in the development of swarm systems, crowd management, wireless sensor network and
    smart city applications.

    \textit{ScaFi} only supports JVM and web-based applications.
    \item \textbf{Protelis} \cite{10.1145/2695664.2695913} is a programming language designed to simplify the development of resilient and well-structured networked systems, and can be integrated into various simulation frameworks. 
    It provides a Java-hosted implementation of the field calculus through the \texttt{protelis-lang} library, offering a domain-general foundational API for aggregate programming \cite{8064092}.
    \begin{figure}
        \centering
        \fbox{\includegraphics[width=.8\linewidth]{figures/protelis.png}}
        \caption{Protelis architecture.}
        \label{fig:protelis-architecture}
    \end{figure}
    The Protelis architecture (\Cref{fig:protelis-architecture}) relies on an interpreter that periodically executes pre-parsed aggregate programs, enabling communication among devices and interaction with the environment.
    However, since it is built on the Xtext framework for domain-specific languages and requires a JVM to run, its deployment is limited to Java-compatible devices, reducing platform heterogeneity.

\end{itemize}

\subsection{Lightweight communication protocols}
In the context of decentralized and distributed messaging systems, \textbf{lightweight communication protocols} are essential for efficient data exchange among devices with limited resources.
A lightweight protocol minimizes overhead transmitted on top of the functional data, useful in scenarios where bandwidth, power, or processing capacity is limited.
With the proliferation of \ac{IoT} and mobile devices, these protocols have become crucial in modern networking.

Keeping in mind the distributed nature of the system, we can consider the following technologies.

\textbf{\ac{BLE}} formerly marked as \textit{Bluetooth Smart}, is a wireless \ac{PAN} technology designed for short-range communication with low power consumption.
\ac{BLE} uses the same 2.4 GHz radio frequency as classic Bluetooth but employs a different protocol stack optimized for energy usage.
It has no compatibility with classic Bluetooth, meaning that devices supporting only one of the two standards cannot communicate directly.

\ac{BLE} supports device discovery and connection through low-duty advertising and scanning cycles, enabling the creation of ad-hoc networks for proximity-based communication.

Another similar protocol is \textbf{Wi-Fi Direct}, a wireless standard that enables devices to connect directly (using Wi-Fi) to each other without the need for a traditional access point or router.
It allows peer-to-peer communication using standard Wi-Fi technology, offering higher data transfer rates and longer range compared to Bluetooth-based solutions.
\begin{table}[h!]
\centering
\caption{Comparison between \ac{BLE} and Wi-Fi Direct.}
\label{tab:ble-wifidirect}
\begin{tabular}{p{4cm}p{5cm}p{5cm}}
\toprule
\textbf{Feature} & \textbf{\ac{BLE}} & \textbf{Wi-Fi Direct} \\ 
\midrule

\textbf{Communication range} & Typically up to 50 meters (depending on environment) & Up to 200 meters (depending on device and power) \\[4pt]
\midrule

\textbf{Data rate} & Up to 2 Mbps (BLE 5.0) & Up to 250 Mbps \\[4pt]
\midrule

\textbf{Consumption} & Very low, optimized for battery-powered devices & Higher, comparable to standard Wi-Fi \\[4pt]
\midrule

\textbf{Network topology} & Simple connections or small mesh networks & Group-based topology with a dynamically assigned group owner \\[4pt]
\midrule

\textbf{Connection setup} & Fast, lightweight pairing through advertising and scanning & Slower setup, requires negotiation between devices \\[4pt]
\midrule

\textbf{Use cases} & Sensor networks, wearables, proximity-based messaging & File sharing, multimedia streaming, ad-hoc data exchange \\[4pt]
\midrule

\textbf{Advantages} & Energy efficient, widely supported, ideal for IoT & High throughput, longer range, infrastructure-free \\[4pt]
\midrule

\textbf{Limitations} & Limited bandwidth and range & Higher energy consumption, more complex setup \\
\bottomrule
\end{tabular}
\end{table}

The table \Cref{tab:ble-wifidirect} summarizes the main differences between \ac{BLE} and Wi-Fi Direct.

On the other hand, \textbf{\ac{MQTT}} relies on a central broker to manage message distribution.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/mqtt.png}}
    \caption{MQTT architecture, illustrating the publish-subscribe model with clients and a central broker.}
    \label{fig:mqtt-architecture}
\end{figure}
It follows a publish-subscribe model (\Cref{fig:mqtt-architecture}) where the centralized server known as Broker is connected to various devices which are Clients \cite{usmani2021mqtt}.
The latter publish messages to specific topics, while subscribers receive only the data relevant to them.

\ac{MQTT} is widely used in \ac{IoT} systems due to its lightweight nature and efficient use of bandwidth.

In the current implementation of the proposed application \ref{goal:application}, \ac{MQTT} is employed as the communication layer to handle messages across devices. 
Although it relies on a central broker and is therefore not fully decentralized, its advantages make it suitable for prototyping and testing the distributed algorithm \ref{goal:algorithm}. 
Future developments may involve replacing \ac{MQTT} with peer-to-peer technologies such as Bluetooth, to achieve complete decentralization.


\chapter{Contribution}

You may also put some code snippet (which is NOT float by default), eg: \cref{lst:random-code}.

\lstinputlisting[float,language=Java,label={lst:random-code}]{listings/HelloWorld.java}

\section{Fancy formulas here}

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter


\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}
