\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acro}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}

\newcommand\YAMLcolonstyle{\color{red}\mdseries}
\newcommand\YAMLvaluestyle{\color{blue}\mdseries}

\school{\unibo}
\programme{Corso di Laurea Triennale in Ingegneria e Scienze Informatiche}
\title{Multi-platform distributed systems with Aggregate Computing in Kotlin: the case of proximity messaging}
\author{Luca Marchi}
\date{\today}
\subject{Programmazione ad Oggetti}
\supervisor{Prof. Pianini Danilo}
\cosupervisor{Dott.ssa Cortecchia Angela}

\session{III}
\academicyear{2024-2025}

\acsetup{first-style=long-short}


\lstdefinelanguage{yaml}{
  keywords={true,false,null,y,n},
  keywordstyle=\color{purple}\bfseries,
  basicstyle=\ttfamily\scriptsize,                                 % assuming a key comes first
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\ttfamily,
  stringstyle=\YAMLvaluestyle\ttfamily,
  moredelim=[l][\color{orange}]{\&},
%   moredelim=[l][\color{magenta}]{*},
  moredelim=**[il][\YAMLcolonstyle{:}\YAMLvaluestyle]{:},   % switch to value style at :
  morestring=[b]',
  morestring=[b]",
  literate =    {---}{{\ProcessThreeDashes}}3
                {>}{{\textcolor{red}\textgreater}}1     
                {|}{{\textcolor{red}\textbar}}1 
                {\ -\ }{{\mdseries\ -\ }}3,
}



\DeclareAcronym{IoT}{
  short = IoT,
  long  = Internet of Things
}
\DeclareAcronym{KMP}{
  short = KMP,
  long  = Kotlin Multiplatform
}
\DeclareAcronym{DSL}{
    short = DSL,
    long  = Domain Specific Language
}

\DeclareAcronym{UI}{
    short = UI,
    long  = User Interface
}

\DeclareAcronym{GUI}{
    short = GUI,
    long  = Graphical User Interface
}

\DeclareAcronym{P2P}{
    short = P2P,
    long  = Peer-to-Peer
}

\DeclareAcronym{BLE}{
    short = BLE,
    long  = Bluetooth Low Energy
}

\DeclareAcronym{PAN}{
    short = PAN,
    long  = Personal Area Network
}

\DeclareAcronym{MQTT}{
    short = MQTT,
    long  = Message Queuing Telemetry Transport
}

\DeclareAcronym{JC}{
    short = JC,
    long  = Jetpack Compose
}

\DeclareAcronym{TTL}{
    short = TTL,
    long  = Time To Live    
}

\DeclareAcronym{MVVM}{
    short = MVVM,
    long  = Model-View-ViewModel    
}

\DeclareAcronym{QoS}{
    short = QoS,
    long = Quality of Service
}

\DeclareAcronym{CI}{
    short = CI,
    long  = Continuous Integration
}

\DeclareAcronym{JVM}{
    short = JVM,
    long  = Java Virtual Machine
}

\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}
In pervasive and ubiquitous computing scenarios, where Internet of Things and mobile devices must communicate under intermittent or absent network infrastructure,
 centralized messaging architectures become fragile, difficult to scale, and unsuitable for proximity-based interactions such as disaster recovery or dense crowd communication.

This thesis explores the use of Aggregate Computing as a foundation for designing decentralized and self-organizing proximity messaging systems.
The proposed solution leverages Kotlin Multiplatform to ensure compatibility across heterogeneous devices and employs Collektive as the underlying Aggregate Computing framework.

At the core of the system lies a gossip-based algorithm that disseminates messages through local, neighbor-to-neighbor exchanges. The algorithm follows a Bellman-Ford-like approach, computing distance gradients from each node to a source to identify the shortest propagation paths. 
It supports multiple message sources and includes configurable parameters such as message expiration time and maximum propagation distance to control propagation scope.

The messaging logic is integrated into Echo, a cross-platform mobile application (Android/iOS) developed with Kotlin Multiplatform and Jetpack Compose Multiplatform for the user interface. The application currently employs the MQTT protocol as the transport layer for communication.

This work contributes to the field of decentralized communication by demonstrating how Aggregate Computing principles can be effectively applied to design robust, scalable, and proximity-aware messaging systems for dynamic, infrastructure-less environments.

Future developments will focus on integrating peer-to-peer protocols, such as Bluetooth or Wi-Fi Direct, to achieve a fully decentralized architecture and Internet-less communication.
\end{abstract}

\begin{dedication} % this is optional
    Dedication...
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
\listoftables      % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
This chapter introduces the overall purpose and scope of the thesis. 
It begins by presenting the scientific and technological context in which this work is situated, highlighting the state of the art and
the motivations that led to the development of a decentralized proximity-based messaging system. 
Subsequently, it outlines the research objectives, methodological approach, and main contributions of the study.


%----------------------------------------------------------------------------------------
\section{Context}
In a world where \ac{IoT} devices are becoming increasingly prevalent,
    the need for efficient and reliable communication systems is paramount (\Cref{fig:iot-devices}).
    \begin{figure}[h!]
        \centering
        \fbox{\includegraphics[width=.8\linewidth]{figures/iot-devices.png}}
        \caption{Our world is increasingly populated with a wide range of computing devices, embedded in our environment and with many opportunities for local and even location-independent interactions on fixed network infrastructures~\protect\cite{beal2015aggregate}.}
        \label{fig:iot-devices}
    \end{figure}
    

    The interactions between neighboring devices play a crucial role in enabling seamless data exchange and coordination,
    so there is the need to design networks with infrastructures that support scalability, adaptability and reusability \cite{beal2015aggregate}.
    In the past, it was reasonable to use a programming model that focused on the
    individual computing device, and its relationship with one or more users.
    However, as systems have grown in scale and complexity with the number of computing devices rising,
    this method has become inadequate.

    Traditional network architectures, rely heavily on centralized
    infrastructures, making them unsuitable for scenarios such as disaster recovery or interactions with neighboring devices.
    The computational model of \textit{Aggregate Computing} provides a promising
    approach to address these challenges by enabling decentralized and self-organizing systems \cite{viroli2019aggregate}.

    Building on this concept, this thesis explores how Aggregate Programming
    can support distributed and proximity-based architecture, operating efficiently without centralized control.



\subsection{Aggregate Programming}
\textbf{Aggregate Programming} is a distributed systems paradigm that simplifies programming large networks of devices by focusing on the global behavior rather than the individual device.
It shifts the abstraction to view the network as an aggregate, an agglomeration of nodes that collectively exhibit certain behaviors.
This model is particularly well-suited for scenarios where devices need to coordinate and collaborate based on local interactions, such as in \ac{IoT} applications.

As discussed in distributed field programming \cite{viroli2019aggregate}, there are principles to follow when designing large-scale systems:
\begin{itemize}
    \item The mechanisms ensuring robust coordination should operate transparently in the background, so that programmers don't need to manage them directly.
    \item The composition of modules and subsystems should be simple and predictable, allowing developers to clearly understand the consequences of combining components.
    \item Large-scale distributed systems often consist of multiple heterogeneous subsystems, each of which may require different coordination strategies depending on the region or context in time.
\end{itemize}
Aggregate Programming aims to overcome these challenges through three fundamental principles:
\begin{enumerate}
    \item The computational target is imagined as a region of the environment, with the underlying device-level details abstracted away, potentially even modeled as a continuous spatial domain.
    \item The program logic is expressed as the manipulation of data structures that extend spatially and temporally across that region.
    \item These computations are executed locally by individual devices within the region, which coordinate through resilient mechanisms and proximity-based interactions.
\end{enumerate}
The foundation of this paradigm lies in \textit{Field Calculus} \cite{beal2015aggregate},
a core set of constructs modeling device behavior and interaction. These essential features are captured
in a tiny universal language suitable for mathematical analysis.
The concept of \textbf{field} plays a central role in this context and is inspired by physics, where it is defined as a function mapping every point in a space-time domain to a scalar value.

According to \cite{viroli2019aggregate}, the \textit{field value} $\phi$ is a function

\begin{equation}
\phi : D \rightarrow L
\end{equation}

that maps each device $\delta$ in the domain $D$ to a local value $\ell$ in the range $L$.
This value can change in time with a \textit{field evolution} that maps each point in time to a field value.
\Cref{fig:layers-AP} shows how Aggregate Programming abstracts the complexity of the underlying distributed network and its
 coordination challenges through a sequence of hierarchical layers.
\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/layers-AP.png}}
    \caption{Layered structure of Aggregate Programming, illustrating the abstraction at each level~\protect\cite{beal2015aggregate}.}
    \label{fig:layers-AP}
\end{figure}

The messaging system developed in this thesis was implemented using \textit{Collektive} \cite{amslaurea31080}, 
an \href{https://github.com/Collektive}{open-source} framework designed to simplify the development of distributed systems through the principles of Aggregate Programming. 
Collektive provides developer-oriented APIs (as in \Cref{fig:layers-AP}) used to define and execute aggregate applications.

\subsection{Collektive}
\label{section:Collektive}
\textbf{Collektive} is a framework designed to simplify the development of systems based on the principles of \textbf{Aggregate Computing}. 
It adopts the \textit{Field Calculus} model to provide an intuitive and expressive means for defining aggregate behaviors without requiring low-level implementation details. 
Developed using \ac{KMP}, it supports execution across multiple platforms and devices \cite{amslaurea31080}.

The main features of the framework can be summarized as follows \cite{DBLP:conf/acsos/Cortecchia24}:
\begin{itemize}
\item \textbf{High-Level Abstraction:} Collektive streamlines the creation of distributed behaviors by enabling developers to express coordination logic at a global level, without explicitly managing individual device states.
\item \textbf{Declarative Programming:} The framework promotes a declarative programming model, allowing developers to specify the intended system outcomes, while the runtime transparently handles the coordination and execution mechanisms.
\item \textbf{Dynamic Adaptation:} Applications built with Collektive can dynamically respond to network changes and environmental changes, ensuring robustness and resilience in highly variable environments.
\end{itemize}

Collektive is structured into three main components:

The first and most significant is the \textbf{\ac{DSL}}, which constitutes the core of the framework. 
It leverages \textit{XC} \cite{AUDRITO2024111976}, an experimental programming language designed for the development of homogeneous distributed systems. 
The DSL encapsulates the main Aggregate Computing operators and provides an extensive set of tests to ensure correctness and consistency.

The second component is the \textbf{compiler plugin}, which is divided into two submodules: a frontend component that performs static analysis to detect potentially unsafe or inappropriate
code written using the Collektive DSL, and a backend component that augments the runtime stack by tracking function calls. 
Each time a function is invoked, its name is recorded within a "Stack" data structure to maintain proper execution alignment.
The \textbf{alignment} mechanism is crucial for the correct execution of aggregate programs,
ensuring that each message from a neighbor is automatically matched to a specific \texttt{nbr} (\Cref{fig:layers-AP}) construct of \textit{Field Calculus}, used for communication.
Each construct produces an export, value to be transmitted to neighboring devices.
This export is labeled with the coordinates of the node within the evaluation tree corresponding to that construct. 
All exports generated during computation are collected into a single message, which is then broadcast to neighboring nodes.
This message can be modeled as a value tree: an ordered hierarchy of values produced during the evaluation of each sub-expression of the aggregate program.
The \textit{alignment mechanism} ensures that the evaluation of each construct on a device corresponds precisely to the same construct on its neighbors, maintaining a consistent traversal path within the evaluation tree.

The third component, \textbf{Alchemist-incarnation}, enables the integration of Collektive with the \textit{Alchemist Simulator}  \cite{Pianini_2013},
 an open-source simulator for modeling and experimenting with distributed and pervasive systems. 
 This component allows Collektive programs to be executed within simulated environments, facilitating the validation of aggregate behaviors before deployment on real devices \cite{amslaurea31080}.
\section{Motivations}
In recent years, the proliferation of \ac{IoT} and mobile devices has increased the need for local communication systems capable of operating even without stable network infrastructure. Centralized architectures, although efficient in connected environments, fail to guarantee reliability and resilience in dynamic or disconnected scenarios.
As devices are becoming pervasive and ubiquitous, new models are required to enable coordination and information exchange without relying on fixed infrastructures.
This need motivates the exploration of decentralized and distributed approaches, which can operate robustly in dynamic and limited environments.

% Describe what problem exists and why it's challenging.
% Focus on the technical or conceptual gap your thesis addresses.

\subsection{Problem statement}
Traditional messaging systems and architectures often rely heavily on centralized servers and infrastructures, which are 
unsuitable and vulnerable for scenarios where connectivity is not guaranteed. 
These situations include \textbf{disaster recovery}, the process for restoring an organization's network infrastructure and operations after a disruptive event, such as a natural disaster, cyberattack, or system failure.

In such scenarios, there are several vulnerabilities and challenges to consider:
\begin{itemize}
    \item \textbf{Single point of failure}: Centralized systems are vulnerable to failures of the authority that makes decisions. This can lead to widespread service disruption and outages.
    \item \textbf{Scalability issues}: As the number of devices increases, centralized systems may struggle to manage the growing volume of data and communication, leading to bottlenecks and delayed responses.
    \item \textbf{Limited resilience}: Centralized architectures often lack the redundancy and fault tolerance needed to maintain functionality in the face of network disruptions or device failures.
\end{itemize}
For networks that must overcome the issues described above, the principles of Aggregate Computing are beneficial, 
as they provide a distributed architecture facilitating direct communication between nodes.
% Give practical examples where your system or research could apply — 
% this grounds your thesis in reality and shows relevance.
\subsection{Real world use cases}
As mentioned in the previous sections, there are several scenarios where a decentralized proximity-based messaging system can be particularly beneficial.

The main use case of such system is in emergency situations. 
When natural disasters, or infrastructure failures occur, cellular networks and Internet connections often go down, making it difficult for people to communicate and coordinate rescue efforts.  
Nearby devices can form ad-hoc Bluetooth or Wi-Fi Direct networks, allowing users in the same area to propagate and share messages without relying on centralized servers.

This architecture can also be useful in large \ac{IoT} networks like sensors systems or drones swarms, operating in remote areas and with the need to communicate without continuous Internet access.

The system's decentralized nature fits perfectly for:
\begin{itemize}
    \item Exchanging local environmental data (temperature, humidity, motion).
    \item Maintaining distributed consensus or context awareness among nearby nodes.
    \item Avoiding single points of failure.
\end{itemize}
A practical example includes a network of environmental sensors deployed in a forest to monitor conditions and detect wildfires (\Cref{fig:use-cases}), or sensors in a smart agriculture field that share humidity data to coordinate irrigation locally.
\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/The-proposed-architecture-for-forest-fire-detection.png}}
    \caption{Real-world use case of a decentralized proximity-based messaging application built on Aggregate Computing principles.
     In this scenario, sensors located near the fire detect the event and propagate an alert message to neighboring nodes within the network~\protect\cite{inproceedings}.}
    \label{fig:use-cases}
\end{figure}
% List what your thesis aims to achieve — clearly, concretely, and in your own scope.
% This section connects the problem and use cases to your proposed solution.

\subsection{Goal}
This thesis can be divided into two main goals:
\begin{enumerate}
    \item \label{goal:algorithm} \textbf{Messaging algorithm}: The first goal is to design and implement a decentralized, proximity-based messaging algorithm grounded in the principles of Aggregate Computing. 
    The network operates in a fully distributed manner, without any central server managing message exchange. 
    Each node acts autonomously, coordinating with its neighbors through local interactions and collectively achieving self-organization, thereby eliminating single points of failure. 
    Communication is proximity-based: devices can only interact with nearby nodes, and messages are propagated progressively across the network, layer by layer. 
    The algorithm must also handle dynamic network topologies, where devices can join or leave the network at any time, ensuring robustness and adaptability. 
    Message sources can define both an expiration time and a maximum propagation distance, enabling controlled diffusion and limiting unnecessary communication overhead. 
    The system is implemented using the \textit{Collektive} framework \cite{amslaurea31080}, leveraging \ac{KMP} to ensure cross-platform compatibility across different targets including 
    \ac{JVM}, Javascript (browser), Android, iOS, and native versions (for Windows, MacOS, and Linux, both for x86 and ARM CPUs).
    \item \label{goal:application} \textbf{Mobile application}: The second goal is to develop a multiplatform mobile application using \ac{KMP}. 
    This application leverages the messaging algorithm as core logic to send and receive messages from devices in the network. 
    The app must support both Android and iOS platforms providing a simple, user-friendly interface.
    The \ac{UI} allows users to compose messages, configure parameters (expiration time and propagation distance), and view received messages in real-time.
    Another feature is the anonymization of the users, there is not any registration or login system, the users are completely anonymous. Anybody can use the app without providing any personal information.

\end{enumerate}

\section{State of Art}
In this section, it will be presented the state of the art in the field of decentralized communication systems.
 The focus will be on the main existing systems, Aggregate Computing frameworks, and lightweight communication protocols.
\subsection{Existing systems}
Several communication technologies and systems have been developed over the years to facilitate decentralized data exchange among devices.
The software that has spread the most and gained significant attention includes: \textit{Briar}, \textit{Bridgefy}, \textit{FireChat}.
\subsubsection{Briar}
\textbf{Briar} \cite{briar} is an open-source \ac{P2P} messaging platform designed for secure,
 resilient communication without centralized servers.
It supports multiple transport methods including Bluetooth, Wi-Fi and Tor, with all communication end-to-end encrypted.
Briar provides a mailbox system \textit{Briar Mailbox} that lets the users receive encrypted messages from their contacts while Briar is offline. Next time Briar comes online it will automatically fetch the messages from the Mailbox.
The primary target audience includes activists, journalists, and civil society members who require secure communication in restricted or infrastructure-limited environments.

A notable feature is the ability to install Briar on an Android device directly from another device that already has it installed, facilitating deployment in disconnected scenarios.
Nowadays, the application is available only for Android devices, with no official iOS version.
\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/briar.png}}
    \caption{Diagram illustrating how Briar supports private messaging, public forums, and blogs through multiple transport methods such as Bluetooth, Wi-Fi, and the Internet. \protect\cite{briar}.}
    \label{fig:briar-architecture}
\end{figure}

\subsubsection{Bridgefy}
\textbf{Bridgefy} \cite{bridgefy} is a mobile messaging application that enables offline communication through Bluetooth mesh networking technology.

The platform allows smartphones to connect directly with nearby devices, creating a decentralized mesh network that can relay messages across multiple hops without requiring Internet connectivity.
Originally designed for emergency situations and large gatherings where cellular networks become congested, Bridgefy has been deployed in various crisis scenarios including natural disasters and political protests.

Messages are automatically routed through intermediate devices, extending the effective communication range beyond direct Bluetooth connectivity (typically 100 meters).
Bridgefy uses encryption protocols to secure message transmission; this capability was not available in the app's initial versions.

The service operates on both Android and iOS devices, with a user-friendly interface designed for rapid adoption during emergency situations.
One limitation is the reliance on device density: the mesh network requires sufficient nearby users to establish reliable multi-hop communication paths.


\subsubsection{FireChat}
\textbf{Firechat} was the first popular example of a messaging application that used mesh network topology to communicate between users.

\cite{7937749} FireChat sends messages from one device to another through each user's Wi-Fi or Bluetooth radios, thereby creating a “mesh” of phones receiving and relaying messages even when each message is not viewable on every device (\Cref{fig:firechat-architecture}).
 This method of communication eliminates the need for centralized communication channels such as cellphone towers that every transmission must pass through.
While this system is beneficial in overcrowded networks, it eliminates the possibility of controlling or monitoring the network at one point.

Although not originally intended for this purpose, FireChat was widely adopted during civil protests.
 The application gained popularity in Iraq in 2014, when government restrictions limited Internet access, and later during the 2014 Hong Kong protests (known as the Umbrella Revolution)

Nowadays FireChat is discontinued and no longer available on app stores, the official website is also offline.
\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/bluetooth-mesh.png}}
    \caption{FireChat's mesh networking architecture, where messages are relayed through nearby devices using Wi-Fi and Bluetooth, enabling communication without centralized infrastructure.}
    \label{fig:firechat-architecture}
\end{figure}

\subsubsection{Final considerations} Those three illustrated applications have broadly the same purpose of providing a decentralized approach to messaging.
\textit{Briar} stands out for its strong emphasis on security and privacy, making it suitable for users in sensitive situations. 
\textit{Bridgefy} is the most user-friendly and practical, focused on connecting users in emergency scenarios; encryption was included in later versions.
\textit{FireChat} was the pioneering first popular example, but now outdated and discontinued. It inspired newer applications.

These applications demonstrate the feasibility of decentralized communication, they rely on predefined routing or broadcasting protocols.
 None of them incorporate \textit{spatial awareness} or \textit{self-organizing behavior}, features that are naturally modeled through \textit{Aggregate Computing}.

\subsection{Aggregate Computing frameworks}
There are several frameworks and libraries that facilitate the development of Aggregate Computing applications, 
implementing the principles of field calculus and providing abstractions for defining collective behaviors.
\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/scafi.png}}
    \caption{High-level architecture of the ScaFi framework, illustrating its components ~\protect\cite{CASADEI2022101248}.}
    \label{fig:scafi-architecture}
\end{figure}
Some of the most notable ones include:
\begin{itemize}
    \item \textbf{ScaFi} (Scala Field) is a framework written in Scala for Aggregate Computing \cite{CASADEI2022101248}. 
    It provides a \ac{DSL} and API modules for writing, testing, and running aggregate programs, the high-level architecture of ScaFi is depicted in \Cref{fig:scafi-architecture}.
    \textit{ScaFi} also includes a simulation environment with a \ac{GUI}, integrated with the Alchemist Simulator.
    
    The main applications are in the development of swarm systems, crowd management, wireless sensor network and
    smart city applications.

    \textit{ScaFi} only supports \ac{JVM} and web-based applications, so it is not suitable for the purposes of this thesis, which requires mobile cross-platform compatibility.
    Since \textit{Collektive} is built using \ac{KMP}, it can target Android and iOS devices, allowing the integration of Aggregate Computing principles into a mobile application.
    \item \textbf{Protelis} \cite{10.1145/2695664.2695913} is a programming language designed to simplify the development of resilient and well-structured networked systems.
    It offers an implementation for the interoperability with the Alchemist Simulator, where it can be seen its practical use in the development of aggregate programs.
    It provides a Java-hosted implementation of the field calculus through the \texttt{protelis-lang} library, offering a domain-general foundational API for Aggregate Programming \cite{8064092}.
    \begin{figure}[h!]
        \centering
        \fbox{\includegraphics[width=.8\linewidth]{figures/protelis.png}}
        \caption{Protelis architecture.}
        \label{fig:protelis-architecture}
    \end{figure}
    The Protelis architecture (\Cref{fig:protelis-architecture}) relies on an interpreter that periodically executes pre-parsed aggregate programs, enabling communication among devices and interaction with the environment.
    However, since it is built on the Xtext framework for domain-specific languages and requires a \ac{JVM} to run, its deployment is limited to Java-compatible devices, reducing platform heterogeneity.
    \item \textbf{FCPP} \cite{9196401} (Field Calculus Plus Plus) is a C++ library that implements the Field Calculus paradigm for Aggregate Computing in a highly efficient and extensible manner. 
    It offers a component-based architecture (\Cref{fig:FCPP-architecture}) that supports modular composition and compile-time optimization, enabling parallelism and low-overhead execution. 
    \begin{figure}[h!]
        \centering
        \fbox{\includegraphics[width=.8\linewidth]{figures/FCPP.png}}
        \caption{FCPP architecture.}
        \label{fig:FCPP-architecture}
    \end{figure}
    
    Unlike JVM-based tools, FCPP can target a broader range of platforms, including microcontrollers, thanks to its lightweight design and minimal dependencies. 
    The framework provides layered abstractions for data structures, components, and aggregate functions, facilitating flexible customization for simulation, IoT deployments, or self-organizing cloud systems. 
    Experimental comparisons demonstrate substantial improvements in performance and scalability, with simulations running orders of magnitude faster and using significantly less memory. 
    Overall, FCPP represents a major step toward practical, high-performance implementations of aggregate computing on heterogeneous and resource-constrained devices
\end{itemize}

\subsection{Lightweight communication protocols}
In the context of decentralized and distributed messaging systems, \textbf{lightweight communication protocols} are essential for efficient data exchange among devices with limited resources.
A lightweight protocol minimizes overhead transmitted on top of the functional data, useful in scenarios where bandwidth, power, or processing capacity is limited.
With the proliferation of \ac{IoT} and mobile devices, these protocols have become crucial in modern networking.

Keeping in mind the distributed nature of the system, we can consider the following technologies.

\textbf{\ac{BLE}} formerly marked as \textit{Bluetooth Smart}, is a wireless \ac{PAN} technology designed for short-range communication with low power consumption.
\ac{BLE} uses the same 2.4 GHz radio frequency as classic Bluetooth but employs a different protocol stack optimized for energy usage.
It has no compatibility with classic Bluetooth, meaning that devices supporting only one of the two standards cannot communicate directly.

\ac{BLE} supports device discovery and connection through low-duty advertising and scanning cycles, enabling the creation of ad-hoc networks for proximity-based communication.

Another similar protocol is \textbf{Wi-Fi Direct}, a wireless standard that enables devices to connect directly (using Wi-Fi) to each other without the need for a traditional access point or router.
It allows \ac{P2P} communication using standard Wi-Fi technology, offering higher data transfer rates and longer range compared to Bluetooth-based solutions.
\begin{table}[h!]
\centering
\caption{Comparison between \ac{BLE} and Wi-Fi Direct.}
\label{tab:ble-wifidirect}
\begin{tabular}{p{4cm}p{5cm}p{5cm}}
\toprule
\textbf{Feature} & \textbf{\ac{BLE}} & \textbf{Wi-Fi Direct} \\ 
\midrule

\textbf{Communication range} & Typically up to 50 meters (depending on environment) & Up to 200 meters (depending on device and power) \\[4pt]
\midrule

\textbf{Data rate} & Up to 2 Mbps (BLE 5.0) & Up to 250 Mbps \\[4pt]
\midrule

\textbf{Consumption} & Very low, optimized for battery-powered devices & Higher, comparable to standard Wi-Fi \\[4pt]
\midrule

\textbf{Network topology} & Simple connections or small mesh networks & Group-based topology with a dynamically assigned group owner \\[4pt]
\midrule

\textbf{Connection setup} & Fast, lightweight pairing through advertising and scanning & Slower setup, requires negotiation between devices \\[4pt]
\midrule

\textbf{Use cases} & Sensor networks, wearables, proximity-based messaging & File sharing, multimedia streaming, ad-hoc data exchange \\[4pt]
\midrule

\textbf{Advantages} & Energy efficient, widely supported, ideal for IoT & High throughput, longer range, infrastructure-free \\[4pt]
\midrule

\textbf{Limitations} & Limited bandwidth and range & Higher energy consumption, more complex setup \\
\bottomrule
\end{tabular}
\end{table}

The table \Cref{tab:ble-wifidirect} summarizes the main differences between \ac{BLE} and Wi-Fi Direct.

\subsubsection{\ac{MQTT}}
\label{subsubsection:Mqtt}
\textbf{\ac{MQTT}} (Message Queuing Telemetry Transport) is a lightweight communication protocol based on a centralized \textit{publish-subscribe} architecture. 
It relies on a central server, known as the \textit{broker}, which manages message distribution among connected clients (\Cref{fig:mqtt-architecture}). 

\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/mqtt.png}}
    \caption{MQTT architecture illustrating the publish-subscribe model with clients and a central broker.}
    \label{fig:mqtt-architecture}
\end{figure}

In this model, clients can either \textit{publish} messages to specific \textit{topics} or \textit{subscribe} to topics of interest, receiving only data relevant to them \cite{usmani2021mqtt}. 
The broker acts as an intermediary that decouples message producers and consumers, ensuring reliable and asynchronous communication. 

\ac{MQTT} is widely adopted in \ac{IoT} systems due to its minimal packet overhead, low bandwidth consumption, and persistent session management, making it particularly suitable for constrained devices and unstable network conditions.

The protocol defines three levels of \ac{QoS}, which determine the reliability of message delivery:
\begin{itemize}
    \item \textbf{\ac{QoS} 0 - At most once:} messages are delivered according to the best effort of the underlying network, with no confirmation or retry mechanism. There is no acknowledgment from the receiver.
    \item \textbf{\ac{QoS} 1 - At least once:} ensures that messages are delivered to the receiver at least one time, though duplicates may occur. It requires a PUBACK acknowledgment.
    \item \textbf{\ac{QoS} 2 - Exactly once:} guarantees that each message is received only once by the intended recipient, at the cost of additional network overhead using a four-step handshake (PUBLISH, PUBREC, PUBREL, PUBCOMP).
\end{itemize}

In the current implementation of the proposed application (Section~\ref{goal:application}), \ac{MQTT} is employed as the communication layer to exchange messages across devices. Although it depends on a centralized broker and is therefore not fully decentralized, its simplicity and efficiency make it an ideal solution for prototyping and testing the distributed messaging algorithm (Section~\ref{goal:algorithm}). 

Future developments may involve replacing \ac{MQTT} with (\ac{P2P}) communication technologies, such as Bluetooth, to achieve full decentralization while maintaining the same messaging semantics.


\chapter{Architecture and Implementation}
This chapter presents the main contributions of the thesis, with particular emphasis on the design and implementation of the decentralized messaging system. 
It details the architectural choices, software components, and underlying mechanisms that enable message propagation through gossip-based aggregate behaviors, highlighting how these elements collectively realize the system's objectives and support its cross-platform deployment.

\section{Requirements}
This section outlines both the functional and non-functional requirements of the messaging system developed in this thesis.
It describes what the system is expected to accomplish, its qualities, constraints, and performances.

The requirements refer to both the messaging algorithm itself (see \ref{goal:algorithm}) and the mobile application (see \ref{goal:application}).
\subsection{Functional requirements}
The functional requirements define the features, behaviors, and operations that the messaging system must support.
\subsubsection{Aggregate Computing algorithm}
\label{subsection:requirements-algorithm}
The messaging algorithm represents the Aggregate Computing layer, the core logic of the system.
\begin{enumerate}
    \item \textbf{Message propagation}: The algorithm must enable nodes to create and send messages to other nodes within the network. 
    \item \textbf{Decentralized and proximity-based communication}: Each node should be able to communicate only with its immediate neighbors, the message is propagated in the network through local interactions.
    There is no central authority managing the communication, the system must be fully distributed and autonomous.
    \item \textbf{Parameter configurability}: The algorithm should allow message sources to define the expiration time of the message and the maximum propagation distance. 
    With these parameters it is possible to control how long a message remains valid and how far it can spread in the network, limiting unnecessary communication overhead.
    \item \textbf{Dynamic topology handling}: The network topology can change dynamically, with nodes joining or leaving the network at any time. 
    The algorithm must be robust and adaptable to these changes, ensuring continuous message propagation without disruptions.
    \item \textbf{Simulation support}: The algorithm must be executable within a simulated environment to facilitate testing and validation.
     This approach enables controlled experimentation under various network conditions and scenarios, ensuring the correctness and stability of the algorithm before its deployment on real devices.
\end{enumerate}

\subsubsection{Mobile Application}
The mobile application serves as the \ac{UI} for the messaging system, providing users both an interface and a runtime environment for the algorithm.
\begin{enumerate}
    \item \textbf{Cross-platform compatibility}: The application must be supported on both Android and iOS platforms.
    \item \textbf{User interface}: The application should provide a simple and intuitive \ac{UI} that allows users to compose messages, set parameters (expiration time and propagation distance), and view received messages in real-time.
    \item \textbf{GPS integration}: The application uses the device's GPS to determine its location, which is essential to compute distances between nodes for message propagation. 
    \item \textbf{Communication layer}: A lightweight communication protocol must be used to send messages between the various nodes in the network.
\end{enumerate}

\subsection{Non-functional requirements}
The non-functional requirements specify the quality attributes, constraints, and performance criteria that the messaging system must meet,
defining how well the functions should be performed.
\begin{itemize}
    \item \textbf{Code alignment}: One of the main non-functional requirements of the system is the code alignment between the simulator
and the mobile application.
This ensures that the same algorithmic logic is shared across both environments, minimizing discrepancies between
simulation and real-world execution.
In practice, the aggregate algorithm is implemented as a common API, which can be invoked identically within the
simulation framework and the mobile runtime.
This alignment is fundamental, as the distributed nature of the system requires extensive validation under multiple-node scenarios.
\item \textbf{Scalability}: The system must sustain acceptable performance levels as the number of participating nodes increases, ensuring that the aggregate computation cycle executes periodically without noticeable degradation on mobile devices. 
\item \textbf{Maintainability and Extensibility}: The codebase must be maintainable and extensible, enabling future developers to easily understand, modify, and enhance the system. These qualities are achieved through modular architectural design, comprehensive documentation, and adherence to established coding standards. Furthermore, the system architecture should be flexible enough to support the integration of new communication protocols or additional functionalities without requiring significant refactoring.

\end{itemize}


\subsection{Analysis}
To address these requirements and challenges, the system adopts a \textbf{decentralized architecture} based on the principles of \textit{Aggregate Computing}, a computational paradigm that models systems as collections of interacting devices operating in a spatial environment. 
In this model, each device (or node) executes the same aggregate program, which is evaluated locally through periodic computation and communication rounds with \textbf{neighboring devices}. 
By relying solely on local information exchange, global behaviors naturally emerge from the coordination of many simple entities. 
This approach provides several advantages: it promotes \textbf{scalability}, since computation does not depend on centralized coordination; it enhances \textbf{robustness}, as the system can tolerate node failures or dynamic topology changes; and it enables \textbf{self-organization}, allowing complex collective behaviors, such as message diffusion and distance-based message decay, to arise from local rules. 
These properties make Aggregate Computing particularly suited for dynamic, large-scale, and unreliable environments such as mobile ad hoc networks.

Message propagation is achieved through \textbf{gradient algorithm} based on \textbf{gossip}, which naturally reflect spatial proximity and temporal dynamics within the network.

From an implementation perspective, the \textit{Collektive} framework is employed to define and simulate the aggregate behavior of the system, ensuring correctness and reproducibility under controlled conditions. 

The communication layer is currently based on the \textbf{\ac{MQTT}} protocol, which provides a lightweight and reliable \textit{publish/subscribe} mechanism suitable for distributed messaging and initial prototyping. 
Although this choice introduces a centralized broker, it is important to note that Aggregate Computing model inherently abstracts from the underlying communication protocol.
This abstraction ensures that the same aggregate logic remains valid across different infrastructures, enabling flexibility and portability in future implementations.

Finally, the use of \textbf{\ac{KMP}} enables a unified codebase that targets multiple platforms (Android, iOS) facilitating consistency between the simulated and real execution environments.
\section{Network Architecture}
In the following sections, the overall \textbf{architecture} of the messaging system will be described (\Cref{fig:architecture-overview}), focusing on both the design and communication model.
\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/layered-design.png}}
    \caption{High-level overview of the architecture, illustrating the interaction between the different layers of the messaging system.}
    \label{fig:architecture-overview}
\end{figure}
\subsection{Design}
The network is modeled as an undirected graph $G = (V, E)$, where $V$ is the set of nodes representing individual devices,
 and $E$ is the set of edges representing communication links between neighboring nodes (\Cref{fig:network-graph}).
\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.6\linewidth]{figures/network-graph.png}}
    \caption{Layout of a network representation. Image taken from \textit{Alchemist Simulator} illustrating nodes and their communication links. Each node represents a device in the messaging system, and edges denote proximity-based connections enabling message exchange.}
    \label{fig:network-graph}
\end{figure}
A \textbf{node} in the network represents a single device (e.g., a smartphone) running the messaging software.
Each node exhibits the following characteristics:
\begin{enumerate}
\item \textbf{Lifecycle}: The lifecycle of a node begins when it joins the network and discovers its neighboring devices. 
While active, the node periodically executes the aggregate algorithm through computation cycles. 
When the node leaves the network (for example, when the application is closed), it terminates all communication and computation activities.
\item \textbf{State}: Each node maintains a local state that includes its unique identifier, 
a list of neighboring nodes with associated distances, its current message value, and positional information. This state is continuously updated based on local interactions.
\item \textbf{Internal Aggregate Computing logic}: Each node autonomously executes the aggregate algorithm defined in Section~\ref{goal:algorithm}, which governs how messages are generated, propagated, 
and expired according to proximity-based interactions with neighboring nodes.
\end{enumerate}
The network is \textbf{distributed} and \textbf{decentralized}, meaning there is no central authority or server managing the communication.
All the nodes behave like whole systems, they are considered together as a single entity like a computational field, not as a collection of individual devices.
This is achieved through local interactions, each node independently maintains its state and exchanges information with nearby peers, supporting self-organization and resilience.

This type of network is particularly suitable for \textbf{dynamic} and \textbf{scalable} environments by design, since computation and communication depend only on local interactions and nodes can 
join or leave the network seamlessly, without any disruption. 


% \subsection{Communication Model}
% \textbf{TODO: Describe the communication model in detail.}
% Expiration time (TTL - Time To Live), Maximum propagation distance (spatial limit), Describe how nodes discover their neighbors
% The system currently employs the \textbf{\ac{MQTT}} protocol as the transport layer to facilitate message exchange among nodes.


\section{Technologies}
\subsubsection{Kotlin Multiplatform}
\textbf{\ac{KMP}} is the programming framework adopted for both the implementation of the messaging algorithm and the development of the mobile application. 

Kotlin is a modern, statically typed, cross-platform programming language that supports type inference and emphasizes conciseness, safety, and interoperability. 
It is fully compatible with Java, as the \ac{JVM} version of its standard library relies on the Java Class Library, enabling seamless integration with existing Java ecosystems.

The primary goal of Kotlin Multiplatform is to streamline the development of cross-platform applications 
by allowing developers to share common code across multiple targets (such as Android, iOS, \ac{JVM}, and Web) while maintaining platform-specific implementations only where necessary. 
This approach greatly reduces code duplication, accelerates development cycles, and ensures consistency across different environments.

In this project, KMP enables the reuse of the same Aggregate Computing logic and communication components across both the simulation and mobile application. 
Compilation targets are defined within the Gradle build configuration, which automates the generation of platform-specific binaries from the shared codebase.


\subsubsection{Collektive}
\textbf{Collektive} is used as Aggregate Computing framework to implement the messaging algorithm (see \Cref{section:Collektive}).

\subsubsection{Compose Multiplatform}
\textbf{Compose Multiplatform} is the UI framework used to implement the \ac{GUI} of the application on both Android and iOS. 
It is based on \textit{\ac{JC}}, Google's declarative toolkit for building native Android interfaces, and extends its capabilities to multiple platforms through the \ac{KMP} ecosystem.

Compose Multiplatform enables developers to define a single, shared user interface in Kotlin, which is then rendered natively on each target platform. 
This approach allows the same declarative UI components and logic to be reused across environments, 
ensuring a consistent design and behavior while maintaining native performance and responsiveness.

In this project, Compose Multiplatform has been adopted to design the messaging application's \ac{GUI}, allowing users to create, send, and visualize
messages within a unified layout. 
By sharing the same UI code between Android and iOS, the development process is simplified, reducing maintenance overhead and ensuring visual consistency across platforms.


\subsubsection{Gradle}
\textbf{Gradle} is a powerful build automation and dependency management system widely used in modern software development, particularly for projects based on Java, Kotlin, and Groovy. 
It is designed for flexibility, scalability, and efficiency, making it one of the most popular tools for managing complex, multimodule applications. 
Gradle employs a declarative \ac{DSL}, written in either Groovy or Kotlin, to define build scripts that specify project configurations, dependencies, tasks, and plugins in a concise and human-readable format.

The build process in Gradle is organized around \textit{tasks}, which represent individual units of work, such as compiling source code, running tests, packaging applications, or generating documentation. 
Developers can define custom tasks and establish dependencies among them, allowing precise control over the execution order and workflow of the build process. 
Gradle also supports parallel task execution and incremental builds, improving efficiency and reducing build times.

In the context of this project, Gradle is used to configure the Kotlin Multiplatform environment, manage platform-specific dependencies, and generate binaries for multiple targets, including Android and iOS. 
Its integration with the Kotlin DSL ensures a consistent and automated build process across all platforms, simplifying development and maintaining reproducibility across simulation and deployment environments.

\subsubsection{\ac{MQTT}}
\textbf{\ac{MQTT}} protocol is used as the communication layer to send messages between the various nodes in the distributed network (see \Cref{subsubsection:Mqtt}).

\section{Messaging with Aggregate Computing}
The core logic of the messaging system is implemented using the \textit{Collektive} framework, which provides the necessary abstractions and tools to define aggregate behaviors.

% The algorithm that underpins it is designed to respect the requirements outlined in \Cref{subsection:requirements-algorithm}.
In this section it will be described the algorithm that underpins the system and how it meets the requirements outlined in \Cref{subsection:requirements-algorithm}.

\subsection{Gossip behavior}
\textbf{Gossip protocols}, also known as \textbf{epidemic protocols}, are a class of communication algorithms inspired by the way information spreads in social or biological systems. 
They have emerged as a key communication paradigm for large-scale distributed systems due to their simplicity, scalability, and resilience.

In these protocols, each node periodically contacts one or a few other nodes and exchanges information with them.
The dynamics of information propagation closely resemble the spread of an epidemic, leading to high fault tolerance and self-stabilization.
The guarantees obtained from gossip-based communication are inherently probabilistic: such systems achieve high stability under stress and disruption, while scaling gracefully to a very large number of nodes \cite{1238221}.

In the context of \textit{Aggregate Computing}, computation focuses on collective behaviors that emerge from local interactions.
Each node executes the same local program and exchanges data with its neighbors to collectively produce a global pattern (e.g., diffusion, consensus, or gradient formation).
In this sense, \textit{gossip} acts as a mechanism of information diffusion, where nodes iteratively mix their local states with those of their neighbors to approximate global aggregates.

The algorithm developed in this thesis follows a similar \textbf{gossip behavior}, where information spreads through local \ac{P2P} interactions to collectively achieve a consistent global state in a decentralized and self-stabilizing manner.

\subsubsection{Diffusion speed}
As defined in \cite{1238221}, the \textbf{diffusion speed} of gossip protocols represents the rate
at which information originating from any node spreads and becomes uniformly mixed throughout a distributed network.
It quantifies how quickly local data diffuses across nodes through randomized \ac{P2P} exchanges.

Formally, the diffusion speed $\boldsymbol{T(\delta, n, \epsilon)}$
is defined as the smallest number of rounds required for all (n) nodes' estimates to deviate from the global average by at most a relative error $\epsilon$, with probability at least $1 - \delta$.
This metric provides a unified way to reason about the convergence rate of gossip-based communication mechanisms, regardless of the specific network topology.

In the case of \textbf{Uniform Gossip}, where each node randomly selects a neighbor to exchange information within each round, 
diffusion occurs exponentially fast, with a time complexity of:
\begin{equation}
T(\delta, n, \epsilon) = O(\log(n) + \log(1/\epsilon) + \log(1/\delta))
\end{equation}

demonstrating that even simple randomized communication mechanisms can achieve rapid and robust global convergence.


\subsection{Gradient algorithm}
The purpose of this algorithm is to enable communication between nodes finding the shortest path to a message source.
The algorithm computes, in a fully distributed manner, the minimum distance (\textbf{gradient}) from each node to a designated target (the source that sends the message).
Full algorithm code is reported in \Cref{lst:algorithm-code}.
\lstinputlisting[float, language=Kotlin, label={lst:algorithm-code}, caption={Entire algorithm code.}]{listings/algorithm.kt}


This is a \textbf{Bellman-Ford} style algorithm, applied over the network graph:
\begin{itemize}
    \item \textbf{Graph} $\rightarrow$ undirected weighed graph $G = (V, E)$ where $V$ is the set of nodes and $E$ is the set of edges.
    \item \textbf{Nodes} $\rightarrow$ each node $u \in V$ represents a device in the network.
    \item \textbf{Weights} $\rightarrow$ each edge $(u, v) \in E$ has an associated weight $w(u, v)$ representing the distance between nodes $u$ and $v$.
    \item \textbf{Relaxation} $\rightarrow$ the algorithm iteratively updates the estimated distances to each node by considering all edges and their weights, gradually converging to the shortest path.
\end{itemize}


\subsubsection{Initialization}
The algorithm starts by initializing the nodes. 
Each node first of all checks if it is the source node (the one that created the message).
If it is, it sets its distance to zero and prepares the message content, 
otherwise it initializes its distance to infinity indicating that it has not yet received the message (\Cref{lst:initialization-code}).

\lstinputlisting[language=Kotlin,label={lst:initialization-code}, caption={Initialization code.}]{listings/initialization.kt}

Using data class \texttt{GossipGradient} (\Cref{lst:gossip-gradient-dataclass-code}) to keep track of the current path the message has taken from the origin to the current node with the estimated distance.



\lstinputlisting[float, language=Kotlin,label={lst:gossip-gradient-dataclass-code}, caption={Data structure representing a state in a gossip-based gradient algorithm.}]{listings/GossipGradient.kt}
Each node starts with \texttt{path = listOf(localId)} because the path stored in a node's gossip ends with that node's ID and 
for every round a neighbor copies your path and then calls \texttt{addHop} to add its own ID to the path, so the invariant stays true.

\subsubsection{Sharing logic and distance computation}
Message dissemination across the network is achieved using Collektive's \texttt{share} function, a fundamental building block of the framework, used to model stateful and continuous interactions among neighboring devices. 
It enables each node to maintain and update a local value over time while exchanging this value with its neighbors during each computational round. 
Starting from an initial value, the construct applies a transformation function that combines the device's current state with the most recent values received from neighboring nodes, producing a new local result that is then shared back with them.
\texttt{share} broadcasts the same result to all the neighbors, capturing the space-time evolution of collective computations and allowing the emergence of global behaviors from local updates.

At each computational round $k$, every node $u$ reads the gossip messages shared by its neighbors (\texttt{neighborsGossip}) and updates its local state accordingly. Based on this information, the node applies a relaxation step to compute the minimum distance to the message source. For each neighbor $v \in \texttt{neighbors}(u)$, the relaxation is defined as:
\begin{equation}
\boldsymbol{d_{u}^{k+1} = \min(d_{u}^{k},\ d_{v}^{k} + w(v, u))}
\end{equation}
where $w(v, u)$ represents the communication cost or weight of the edge between nodes $v$ and $u$.
This iterative process propagates distance information throughout the network, allowing each node to estimate its proximity to the source node (\Cref{lst:relaxation-code}).

\lstinputlisting[language=Kotlin,label={lst:relaxation-code}, caption={Relaxation code to compute the minimum distance from each node to the source.}]{listings/relaxation.kt}

This approach is also safe for non-source nodes, which initially have an empty \texttt{content} 
field and an infinite \texttt{distance}. 

As a result, their state is not propagated to other nodes, since the condition \texttt{neighborGossip.content.isNotEmpty()} and the relaxation step prevent the adoption of invalid or uninitialized data. 
These nodes remain inactive until they receive and relay a valid message proposal, at which point their state becomes part of the propagation process.

\subsubsection{Loop avoidance}
The \texttt{path} field contained in the \texttt{GossipGradient} data class is also used to prevent cycles during message propagation (\Cref{lst:loop-avoidance-code}).

To achieve this, a copy of each neighbor's path is created, excluding the neighbor's own identifier. This produces a sequence representing all the hops that precede that neighbor in the propagation chain.

Two checks are then performed to detect and reject cyclic paths. The first condition, \texttt{it == localId}, prevents self-cycles by discarding any proposal that has already passed through the current node.
The second, \texttt{it in neighbors}, filters out proposals that traverse any of the current node's neighbors other than the one under consideration, thereby avoiding “ping-pong” exchanges between adjacent nodes.

Together, these checks ensure that message propagation remains acyclic, improving the efficiency and correctness of the gossip process.

\lstinputlisting[language=Kotlin,label={lst:loop-avoidance-code}, caption={Loop avoidance code preventing cycles during message propagation.}]{listings/loopAvoidance.kt}

\subsubsection{Message expiration and spatial limits}
To regulate both the lifespan and spatial reach of messages within the network, 
the algorithm takes as input two key parameters: the \ac{TTL} (\texttt{lifeTime}) and the maximum propagation distance (\texttt{maxDistance}).
Before forwarding a message, each node applies a filtering step to ensure that only valid messages, those that have not expired and remain within the defined spatial range, are relayed to neighboring nodes (\Cref{lst:expiration-code}).

\lstinputlisting[language=Kotlin,label={lst:expiration-code}, caption={Filtering logic enforcing message expiration and spatial propagation limits.}]{listings/filter.kt}
\subsubsection{Multiple sources}
In a large-scale, real-world deployment, it is common for multiple nodes to generate and transmit messages simultaneously.
The algorithm is designed to handle this scenario effectively, allowing multiple sources to coexist and propagate their messages independently without interference.

This behavior is achieved by treating each message source as an independent entity, with every node maintaining separate state information for each active message in the network.
Initially, a gossip-based self-stabilization step is applied to the set of active sources (\Cref{lst:sources-sharing-code}).

\lstinputlisting[language=Kotlin,label={lst:sources-sharing-code}, caption={Gossip-based self-stabilization of the message sources.}]{listings/sources-sharing.kt}

After stabilization, the gossip-gradient algorithm described previously is executed independently for each source (\Cref{lst:multisources-code}).


Since the implementation relies on the \texttt{share} construct, iterating over all sources requires the use of the \texttt{alignedOn} operator. This operator ensures that only nodes executing the same \texttt{alignedOn(sourceId)} instance exchange values with one another, thereby preventing interference between computations associated with different sources.
\lstinputlisting[float, language=Kotlin,label={lst:multisources-code}, caption={Execution of the gossip-gradient algorithm for multiple concurrent sources.}]{listings/multipleSources.kt}
\subsubsection{Time complexity}
Let $n = |V|$ be the number of nodes, $m = |E|$ the number of links, and $s$ the number of sources. 
The gradient phase is Bellman-Ford-like with non-negative weights, the pure distance relaxation costs 
$O(nm)$ per source in the worst case (thus $O(n^3)$ on dense graphs with $m \approx n^2$). 

In the implementation presented here, the \textit{loop-avoidance} check scans the neighbor's path prefix, adding an 
$O(n)$ factor per neighbor. 
This yields $O(mn)$ work per round and up to $O(n)$ rounds, i.e., $O(mn^2)$ per source 
(dense: $O(n^4)$). 

Across $s$ sources, multiply the bounds: $O(snm)$ (dense: $O(sn^3)$) for the pure gradient, 
or $O(smn^2)$ (dense: $O(sn^4)$) with full path checking. 
Bounding the path inspection to a constant $k$ (or removing it) 
recovers the $O(snm)$ worst-case bound.


\section{Mobile Application}

\begin{figure}[hb!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/screenshot-echo.png}}
    \caption{Illustration of the Echo application interface. On the left is an iOS device, and on the right is an Android device.
    These two smartphones are exchanging messages with each other.}
    \label{fig:screenshot-echo}
\end{figure}
The mobile application serves as the \ac{GUI} of the messaging system, providing users with both an intuitive interface and a runtime environment for executing the algorithm.

\textbf{Echo} is the name chosen for the application, as it evokes the idea of messages reverberating through the network within a limited range and time frame, analogous to how sound echoes in space.
The name also recalls the Linux command \texttt{echo}, used to print messages to the terminal, symbolizing communication and simplicity.

The application is implemented using \ac{KMP} and Compose Multiplatform, ensuring \textbf{cross-platform} compatibility between Android and iOS devices (\Cref{fig:screenshot-echo}).
This section describes the architecture and implementation details of the app.


\subsection{Architecture}

The architecture of the \textbf{Echo} application is designed to be modular and scalable, enabling easy maintenance and future extensions.
It follows the \textbf{\ac{MVVM}} architectural pattern, which separates the user interface, business logic, and data management into distinct layers (\Cref{fig:app-MVVM}).

\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/mvvm.png}}
    \caption{Illustration of the MVVM architectural pattern.}
    \label{fig:app-MVVM}
\end{figure}

The \ac{MVVM} pattern consists of three main components:
\begin{itemize}
    \item \textbf{Model}: Represents the data and business logic of the application. It is responsible for managing data sources, such as local databases or APIs, and performing necessary transformations or computations.
    \item \textbf{View}: Defines the \ac{UI} layer, the part of the application that the user interacts with. It displays data exposed by the ViewModel and forwards user interactions (e.g., button clicks or text input) back to it.
    \item \textbf{ViewModel}: Acts as an intermediary between the Model and the View. It retrieves and processes data from the Model, exposing it in a \ac{UI}-friendly form. 
    The ViewModel maintains the application state and employs observable data structures to notify the View of any updates.
\end{itemize}
The image in \Cref{fig:mvvm-echo} illustrates how the \textbf{Echo} application implements the \ac{MVVM} architecture.

The \textbf{View layer}, built with Compose Multiplatform, in files such as \texttt{App.kt}, \texttt{Screen.kt}, and \texttt{TopBar.kt}, is responsible for rendering the \ac{GUI} and 
for observing the application state through Kotlin's \texttt{StateFlow} mechanism, ensuring reactive updates whenever the underlying data changes.

The \textbf{ViewModel layer}, embodied by the \texttt{NearbyDevicesViewModel} class, acts as the central coordinator that manages application state and orchestrates business logic.
It exposes observable state variables including message lists, connection status, discovered devices, 
current GPS location, and sending indicators, while providing action methods such as \texttt{sendMessage()}, \texttt{startCollektiveProgram()} , and \texttt{startLocationTracking()} that the View layer invokes in response to user interactions.

The \textbf{Model layer} comprises immutable data classes including:
\begin{itemize}
    \item \texttt{ChatMessage}: Application-level data structure for displaying messages in the UI.
    \item \texttt{DeviceLocationHeartbeat}: Data class for sharing device location and heartbeat information via \ac{MQTT}.
    \item \texttt{Message}: Internal data structure representing a message used by the gossip algorithm during propagation.
    \item \texttt{GossipConfig}: Configuration for default gossip parameters such as \ac{TTL} and maximum distance.
\end{itemize}

The \textbf{Service layer} contains the infrastructure components: the Collektive aggregate computing framework, the MQTT mailbox for network communication, platform-specific location services, and the gossip algorithm implementations which the ViewModel coordinates to perform operations.

\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth, height=0.8\linewidth, keepaspectratio]{figures/mvvm-echo.png}}
    \caption{MVVM architecture of the \textbf{Echo} mobile application.}
    \label{fig:mvvm-echo}
\end{figure}


\subsection{Layered design}

The layered design of the application is illustrated in \Cref{fig:app-layered-design}.
Each layer is described below following a bottom-up approach.

\textbf{Collektive Engine} layer acts as the Aggregate Computing runtime environment responsible for managing and executing aggregate programs, including the messaging algorithm.
It provides primitives for defining computational fields, sharing data among neighbors, and performing distributed computations across the network, such as \texttt{share}, \texttt{alignedOn}, and \texttt{neighboring} (\Cref{lst:collektive-code}).

\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/app-layered-design.png}}
    \caption{Layered design of the mobile application, illustrating the interaction between the different components.}
    \label{fig:app-layered-design}
\end{figure}

\lstinputlisting[float, language=Kotlin, label={lst:collektive-code}, caption={Collektive engine setup.}]{listings/Collektive.kt}

The \textbf{Location Services} layer provides access to the device's native location APIs to obtain accurate positional information (\Cref{lst:gps-data-code}).
It captures latitude and longitude values, essential for computing distances between nodes in the messaging algorithm, and updates the device's location in real time.

\lstinputlisting[float, language=Kotlin, label={lst:gps-data-code}, caption={Data class for GPS location.}]{listings/DeviceLocation.kt}

To compute distances between two devices with known coordinates, the Haversine formula is used:
\begin{equation}
d = 2r \cdot \operatorname{arcsin}\left(\sqrt{\sin^2\left(\frac{\Delta\phi}{2}\right) + \cos(\phi_1)\cos(\phi_2)\sin^2\left(\frac{\Delta\lambda}{2}\right)}\right)
\end{equation}

The location data obtained locally is shared through the \textbf{Transport Layer}, enabling neighbor awareness without direct coupling to the Collektive Engine.
This layer uses the \ac{MQTT} protocol as its communication mechanism, relying on the public broker \footnote{\label{mosquitto}\url{https://test.mosquitto.org/}} over WebSocket on port 8080 instead of the default TCP port 1883.
Using port 8080 improves firewall compatibility, since many private or public networks block non-standard ports like 1883, while 8080 is commonly allowed for web traffic.
This setup also ensures compatibility with browsers and WebApps, facilitating future extensions of the application to web platforms.

The Transport Layer is responsible for the following functionalities:

\begin{itemize}
    \item \textbf{Neighbor discovery}: Each device periodically broadcasts its presence via a heartbeat message, indicating active network connectivity, to the wildcard topic \texttt{echo/heartbeat/+} (\Cref{lst:heartbeat-code}).
    \lstinputlisting[language=Kotlin, label={lst:heartbeat-code}, caption={Heartbeat pulse recursive sending function.}]{listings/heartBeat.kt}

    The \ac{QoS} level 0 (\textit{fire and forget}) is used, since heartbeats are ephemeral and frequent, minimizing overhead.
    A timeout mechanism is implemented to remove inactive neighbors (\Cref{lst:cleanHeartBeat-code}): if a device stops sending heartbeats (due to crash, disconnection, or moving away) for more than 5 seconds (\texttt{retentionTime}), it is removed from the neighbor list.

    \lstinputlisting[float, language=Kotlin, label={lst:cleanHeartBeat-code}, caption={Heartbeat pulse cleanup function.}]{listings/cleanHeartBeat.kt}

    \item \textbf{Message delivery}: Each device subscribes to its dedicated topic 
    \\ \texttt{echo/messages/<deviceId>} to receive messages.
    For this purpose, \ac{QoS} level 1 (\textit{at least once}) is used to ensure reliable delivery:
    \begin{enumerate}
        \item The sender publishes a message to the broker.
        \item The broker acknowledges receipt (\texttt{PUBACK}).
        \item The broker forwards the message to subscribers.
        \item The subscriber acknowledges receipt (\texttt{PUBACK}).
        \item If acknowledgment fails, the message is retransmitted.
    \end{enumerate}

    \item \textbf{Location sharing}: GPS coordinates are embedded within the heartbeat payloads (\Cref{lst:GPS-heartbeat-code}), allowing nodes to discover neighbors and compute distances without requiring a separate location-sharing mechanism.
    \lstinputlisting[language=Kotlin, label={lst:GPS-heartbeat-code}, caption={GPS coordinates embedded inside the heartbeat payload.}]{listings/DeviceLocationHeartbeat.kt}
    This design ensures that GPS data is continuously updated through the heartbeat frequency.
\end{itemize}

Finally, the \textbf{Application Layer} encapsulates the core logic of the messaging system.
It implements the decentralized gossip algorithm responsible for message propagation and handles all user-facing features, including message creation, parameter configuration (expiration time and propagation distance), and real-time visualization of messages.

\chapter{Validation}
This chapter describes the validation process undertaken to ensure the correctness of the algorithm.
It's divided into \ac{CI} setup and Simulation experiments.

\section{Continuous Integration}
\ac{CI} is a software development practice that involves automatically building, testing, and validating code changes as they are integrated into a shared repository.
The integrations are made frequently, ensuring that the system remains in a consistently deployable state throughout the development lifecycle.
This approach helps maintain code quality, reduces integration problems, and promotes collaboration among team members.

In this project, \textbf{GitHub Actions} is used as \ac{CI} platform to automate the build processes for both the shared codebase \footnote{\label{collektive-example-repo}\url{https://github.com/Collektive/collektive-examples}} and the mobile application.
The \ac{CI} pipeline is configured to trigger on every push or pull request to the main branch, ensuring that all changes are automatically validated before being merged.

The algorithm was added to \Cref{collektive-example-repo}, repository which hosts various examples of applications built using the Collektive framework.
The \ac{CI} workflow includes the following jobs (\Cref{lst:CI-collektive-examples}):

\lstinputlisting[language=yaml, label={lst:CI-collektive-examples}, caption={CI workflow for Collektive examples.}]{listings/CI-collektive-examples.yml}

\begin{enumerate}
    \item \texttt{build}: it's the main job of the workflow, responsible for the compilation, testing and deployment over three operating systems—Windows, Ubuntu, and macOS.
    Each run begins by checking out the project's source code from the repository, after which the workflow executes the Gradle build and testing phases through the \texttt{build-check-deploy-gradle-action}. 
    This action automates the project verification process by running commands such as \texttt{./gradlew check runAllGraphic}, ensuring that the simulations and validation steps complete successfully.
    \item \texttt{success}: executed after the \texttt{build} job completes, serves as a verification step,
    it checks whether all builds have finished successfully or if any have failed or been cancelled.
\end{enumerate}
\section{Alchemist simulations}
Deploying and testing the messaging system in a real-world environment with many mobile devices can be logistically challenging and require significant resources.
To overcome these challenges, the \textit{Alchemist Simulator} is used to create a controlled environment with multiple nodes where various scenarios can be simulated and analyzed.

The simulations executed through the \texttt{Alchemist Simulator}  are configured using \textbf{YAML} files, which specify the parameters governing the simulation environment, the number and type of nodes, and the associated behavioral models.
The example shown in \Cref{lst:alchemist-simulation-yaml} presents a representative configuration defining a simulation scenario with $50$ regular nodes and $2$ source nodes.
\lstinputlisting[float, language=yaml, label={lst:alchemist-simulation-yaml}, caption={YAML configuration file for the Alchemist simulation.}]{listings/alchemist-simulation.yml}

Each node executes the program \texttt{gossipChatMultipleSourcesEntrypoint} (\Cref{lst:simulation-entry-point}), which serves as the entry point of the simulation.
This component initializes the \emph{gossip-based chat algorithm}, invoking it with predefined parameters such as the message lifetime and the maximum propagation distance, thereby reproducing the intended proximity-based communication dynamics.
\lstinputlisting[float, language=Kotlin, label={lst:simulation-entry-point}, caption={Entry point for the multi-source chat simulation.}]{listings/simulationEntryPoint.kt}

Using the \ac{GUI} provided by the Simulator, it is possible to visualize the network topology and change it, monitor the state of each node in real time and analyze how messages propagate through the network over time.

\section{Simulation with GPS traces}
\texttt{Alchemist} provides the capability to load and simulate scenarios on real-world geographic maps. This feature enables more realistic experiments by incorporating actual spatial data and mobility traces, allowing nodes to move within real urban environments.

To evaluate the behavior of the proposed messaging system under realistic conditions, data from the \textit{Vienna Marathon 2021} event were used to construct a challenging simulation environment (\Cref{fig:marathon-simulation}).
\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/vienna-marathon.png}}
    \caption{Simulation of the messaging system using real-world GPS traces from Vienna's 2021 marathon event.}
    \label{fig:marathon-simulation}
\end{figure}

The simulation involves approximately $1500$ nodes, representing people devices, moving along the city.

\Cref{fig:marathon-simulation} presents a snapshot of the simulation.
The left panel depicts the entire network topology, including all nodes and
 their communication links, whereas the right panel displays the state of a selected node, detailing the messages it has received during execution.

 This large-scale, dynamic environment was selected to test the system's scalability, robustness, and message propagation capabilities in dense and highly mobile network conditions.

\chapter{Conclusions}
This chapter presents the concluding remarks of the thesis, offering a comprehensive synthesis of the main contributions and results achieved throughout the work. It revisits the research objectives, evaluating how they have been addressed through the design and implementation of the proposed decentralized messaging system.

Finally, the chapter outlines prospective directions for further development, identifying possible enhancements, extensions, and open research challenges that may guide future investigations in this domain.
\section{Final considerations}
The primary objective of this thesis was to design and implement a decentralized, proximity-based messaging system founded on the principles of \textbf{Aggregate Computing}. 
To achieve this goal, it was essential to adopt a framework capable of providing suitable abstractions and tools for the development of aggregate programs.

The \textbf{Collektive} framework was selected as the foundation of the system due to its expressive \ac{DSL}, multiplatform capabilities, and seamless integration with the \textbf{Alchemist Simulator}. 
The latter was employed to validate the correctness and performance of the proposed algorithm through a series of controlled simulations.

After the algorithm was designed and validated, it was incorporated as the core message propagation mechanism within \textbf{Echo}, a cross-platform mobile application developed using \textbf{\ac{KMP}}. 
The user interface was implemented with \textbf{Compose Multiplatform}, while \textbf{\ac{MQTT}} was employed as the communication protocol to handle message exchange among devices.

The resulting application supports both Android and iOS platforms, enabling cross-platform interaction and demonstrating the feasibility of integrating Aggregate Computing paradigms within mobile environments.

\section{Future work}
The development of \textbf{Echo} is intended to continue beyond the scope of this thesis. Several enhancements and extensions could be explored to further improve the system's functionality and overcome its current limitations.

A primary objective for future work is the integration of alternative communication protocols, such as Bluetooth or Wi-Fi Direct, as substitutes for the current \ac{MQTT}-based transport layer. This would enable device-to-device message exchange without Internet connectivity, thereby achieving a fully decentralized \ac{P2P} network architecture.

Another planned development involves the publication of the application on official distribution platforms, such as the Google Play Store and Apple App Store, under the department's supervision. 
This step would facilitate real-world testing and user feedback, providing valuable insights for further refinement of the system and validation of its decentralized communication model.
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------



\backmatter


\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}
