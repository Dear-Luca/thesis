\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acro}
\usepackage{booktabs}

\school{\unibo}
\programme{Corso di Laurea Triennale in Ingegneria e Scienze Informatiche}
\title{Multi-platform distributed systems with Aggregate Computing in Kotlin: the case of proximity messaging}
\author{Luca Marchi}
\date{\today}
\subject{Programmazione ad Oggetti}
\supervisor{Prof. Pianini Danilo}
\cosupervisor{Dott.ssa Cortecchia Angela}

\session{II}
\academicyear{2024-2025}

\acsetup{first-style=long-short}
\DeclareAcronym{IoT}{
  short = IoT,
  long  = Internet of Things
}
\DeclareAcronym{KMP}{
  short = KMP,
  long  = Kotlin Multiplatform
}
\DeclareAcronym{DSL}{
    short = DSL,
    long  = Domain Specific Language
}

\DeclareAcronym{UI}{
    short = UI,
    long  = User Interface
}

\DeclareAcronym{GUI}{
    short = GUI,
    long  = Graphical User Interface
}

\DeclareAcronym{P2P}{
    short = P2P,
    long  = Peer-to-Peer
}

\DeclareAcronym{BLE}{
    short = BLE,
    long  = Bluetooth Low Energy
}

\DeclareAcronym{PAN}{
    short = PAN,
    long  = Personal Area Network
}

\DeclareAcronym{MQTT}{
    short = MQTT,
    long  = Message Queuing Telemetry Transport
}

\DeclareAcronym{JC}{
    short = JC,
    long  = Jetpack Compose
}

\DeclareAcronym{TTL}{
    short = TTL,
    long  = Time To Live    
}

\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	

\end{abstract}

\begin{dedication} % this is optional
To my family.
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
\listoftables      % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------
\section{Context}
In a world where \ac{IoT} devices are becoming increasingly prevalent,
    the need for efficient and reliable communication systems is paramount
    \begin{figure}
        \centering
        \fbox{\includegraphics[width=.8\linewidth]{figures/iot-devices.png}}
        \caption{Our world is increasingly populated with a wide range of computing devices, embedded in our environment and with many opportunities for local and even location-independent interactions on fixed network infrastructures~\protect\cite{beal2015aggregate}.}
        \label{fig:iot-devices}
    \end{figure}
    (\Cref{fig:iot-devices}).

    The interactions between neighboring devices play a crucial role in enabling seamless data exchange and coordination,
    so there is the need to design networks with infrastructures that support scalability, adaptability and reusability \cite{beal2015aggregate}.
    In the past, it was reasonable to use a programming model that focused on the
    individual computing device, and its relationship with one or more users.
    However, as systems have grown in scale and complexity with the number of computing devices rising,
    this method has become inadequate.

    Traditional network architectures, rely heavily on centralized
    infrastructures, making them unsuitable for scenarios such as disaster recovery or interactions with neighboring devices.
    The computational model of \textit{Aggregate Computing} provides a promising
    approach to address these challenges by enabling decentralized and self-organizing systems \cite{viroli2019aggregate}.

    Building on this concept, this thesis explores how Aggregate Programming
    can support a proximity and decentralized messaging system in a network.



\subsection{Aggregate Programming}
\textbf{Aggregate Programming} is a distributed systems paradigm that simplifies programming large networks of devices by focusing on the global, system-level behavior rather than the individual behavior of each device.
It shifts the abstraction to view the network as an aggregate, an agglomeration of nodes that collectively exhibit certain behaviors.
This model is particularly well-suited for scenarios where devices need to coordinate and collaborate based on local interactions, such as in \ac{IoT} applications.

As discussed in distributed field programming \cite{viroli2019aggregate}, there are principles to follow when designing large-scale systems:
\begin{itemize}
    \item The mechanisms ensuring robust coordination should operate transparently in the background, so that programmers don’t need to manage them directly.
    \item The composition of modules and subsystems should be simple and predictable, allowing developers to clearly understand the consequences of combining components.
    \item Large-scale distributed systems often consist of multiple heterogeneous subsystems, each of which may require different coordination strategies depending on the region or context in time.
\end{itemize}
Aggregate Programming aims to overcome these challenges through three fundamental principles:
\begin{enumerate}
    \item The computational target is conceived as a region of the environment, with the underlying device-level details abstracted away, potentially even modeled as a continuous spatial domain.
    \item The program logic is expressed as the manipulation of data structures that extend spatially and temporally across that region.
    \item These computations are executed locally by individual devices within the region, which coordinate through resilient mechanisms and proximity-based interactions.
\end{enumerate}
The foundation of this paradigm lies in \textit{field calculus} \cite{beal2015aggregate},
a core set of constructs modeling device behavior and interaction. These essential features are captured
in a tiny universal language suitable for mathematical analysis.
The concept of \textbf{field} plays a central role in this context and originates from physics, where it is defined as a function mapping every point in a space–time domain to a scalar value.

According to \cite{viroli2019aggregate}, the \textit{field value} $\phi$ is a function

\begin{equation}
\phi : D \rightarrow L
\end{equation}

that maps each device $\delta$ in the domain $D$ to a local value $\ell$ in the range $L$.
This value can change in time with a \textit{field evolution} that maps each point in time to a field value.
\Cref{fig:layers-AP} shows how Aggregate Programming abstracts the complexity of the underlying distributed network and its
 coordination challenges through a sequence of hierarchical abstraction layers.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/layers-AP.png}}
    \caption{Layered structure of Aggregate Programming, illustrating the abstraction at each level~\protect\cite{beal2015aggregate}.}
    \label{fig:layers-AP}
\end{figure}

The messaging system developed in this thesis was implemented using \textit{Collektive} \cite{amslaurea31080}, 
an open-source framework designed to simplify the development of distributed systems through the principles of Aggregate Programming. 
Collektive provides developer-facing APIs (as in \Cref{fig:layers-AP}) used to define and execute aggregate applications.

\subsection{Collektive}
\label{section:Collektive}
Collektive is a framework with the purpose of simplifying the definition of Aggregate Computing systems.
To achieve this, Collektive adopts the Field Calculus model, providing an intuitive way to define aggregate
behavior without low-level coding. Built with \ac{KMP}, it can be executed seamlessly on different targets.
Moreover, a compiler plugin was introduced to support function alignment, automatically annotating aligned functions to ensure consistent coordination among nodes
\cite{amslaurea31080}.

The main features of this framework can be summarized as follows \cite{collektive_docs}:
\begin{itemize}
\item \textbf{High-Level Abstraction}: Collektive streamlines the development of distributed behaviors by enabling developers to define coordination logic succinctly, without explicitly handling individual device states.
\item \textbf{Declarative Programming}: The framework adopts a declarative paradigm, allowing developers to specify the desired system outcomes, while the underlying runtime manages the execution details.
\item \textbf{Dynamic Adaptation}: Applications developed with Collektive can automatically adapt to network variations and external inputs, maintaining robustness in dynamic and unpredictable environments.
\end{itemize}

It provides a minimal \ac{DSL} where the developer can specify the
collective behaviour of a network of devices and the devices can directly communicate with each other and execute the same program.

\section{Motivations}
In this section motivations for implementing a decentralized proximity-based messaging system will be illustrated.

In recent years, the proliferation of \ac{IoT} and mobile devices has increased the need for local communication systems capable of operating even without stable network infrastructure. Centralized architectures, although efficient in connected environments, fail to guarantee reliability and resilience in dynamic or disconnected scenarios.
As devices are becoming pervasive and ubiquitous, new models are required to enable coordination and information exchange without relying on fixed infrastructures.
This need motivates the exploration of decentralized and distributed approaches, which can operate robustly in dynamic and connectivity-limited environments.

% Describe what problem exists and why it’s challenging.
% Focus on the technical or conceptual gap your thesis addresses.

\subsection{Problem statement}
Traditional messaging systems and architectures often rely heavily on centralized servers and infrastructures, which are 
unsuitable and vulnerable for scenarios where connectivity is not guaranteed. 
These situations include \textbf{disaster recovery}, the process for restoring an organization's network infrastructure and operations after a disruptive event, such as a natural disaster, cyberattack, or system failure.

In such environments there are several vulnerabilities and challenges to consider:
\begin{itemize}
    \item \textbf{Single point of failure}: Centralized systems are vulnerable to failures of the authority that makes decisions. This can lead to widespread service disruption and outages.
    \item \textbf{Scalability issues}: As the number of devices increases, centralized systems may struggle to manage the growing volume of data and communication, leading to bottlenecks and delayed responses.
    \item \textbf{Limited resilience}: Centralized architectures often lack the redundancy and fault tolerance needed to maintain functionality in the face of network disruptions or device failures.
\end{itemize}
The networks that need to overcome the issues above can benefit from Aggregate Computing principles, which provides
a distributed architecture where the nodes can directly communicate with the neighbors.

% Give practical examples where your system or research could apply — 
% this grounds your thesis in reality and shows relevance.
\subsection{Real world use cases}
As mentioned in the previous sections, there are several scenarios where a decentralized proximity-based messaging system can be particularly beneficial.

The main use case of such system is in emergency situations. 
When natural disasters, or infrastructure failures occur, cellular networks and Internet connections often go down, making it difficult for people to communicate and coordinate rescue efforts.  
Nearby devices can form ad-hoc Bluetooth or Wi-Fi Direct networks, allowing users in the same area to propagate and share messages without relying on centralized servers.

This architecture can also be useful in large \ac{IoT} networks like sensors systems or drones swarms, operating in remote areas and with the need to communicate without continuous Internet access.

The system's decentralized nature fits perfectly for:
\begin{itemize}
    \item Exchanging local environmental data (temperature, humidity, motion).
    \item Maintaining distributed consensus or context awareness among nearby nodes.
    \item Avoiding single points of failure.
\end{itemize}
A practical example includes a network of environmental sensors deployed in a forest to monitor conditions and detect wildfires (\Cref{fig:use-cases}), or sensors in a smart agriculture field that share humidity data to coordinate irrigation locally.
\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/The-proposed-architecture-for-forest-fire-detection.png}}
    \caption{Real-world use case of a decentralized proximity-based messaging application built on Aggregate Computing principles.
     In this scenario, sensors located near the fire detect the event and propagate an alert message to neighboring nodes within the network~\protect\cite{inproceedings}.}
    \label{fig:use-cases}
\end{figure}
% List what your thesis aims to achieve — clearly, concretely, and in your own scope.
% This section connects the problem and use cases to your proposed solution.

\subsection{Goal}
This thesis can be divided into two main goals:
\begin{enumerate}
    \item \label{goal:algorithm} \textbf{Messaging algorithm}: The first goal is to design and implement a decentralized, proximity-based messaging algorithm grounded in the principles of Aggregate Computing. 
    The network operates in a fully distributed manner, without any central server managing message exchange. 
    Each node acts autonomously, coordinating with its neighbors through local interactions and collectively achieving self-organization, thereby eliminating single points of failure. 
    Communication is proximity-based: devices can only interact with nearby nodes, and messages are propagated progressively across the network, layer by layer. 
    The algorithm must also handle dynamic network topologies, where devices can join or leave the network at any time, ensuring robustness and adaptability. 
    Message sources can define both an expiration time and a maximum propagation distance, enabling controlled diffusion and limiting unnecessary communication overhead. 
    The system is implemented using the \textit{Collektive} framework \cite{amslaurea31080}, leveraging \ac{KMP} to ensure cross-platform compatibility across different targets including 
    JVM, Javascript (browser), Android, iOS, and native versions (for Windows, MacOS, and Linux, both for x86 and ARM CPUs).
    \item \label{goal:application} \textbf{Mobile application}: The second goal is to develop a multiplatform mobile application using \ac{KMP}. 
    This application leverages the messaging algorithm as a core library to send and receive messages from devices in the network. 
    The app must support both Android and iOS platforms providing a simple, user-friendly interface.
    The \ac{UI} allows users to compose messages, configure parameters (expiration time and propagation distance), and view received messages in real-time.
    Another feature is the anonymization of the users, there is not any registration or login system, the users are completely anonymous. Anybody can use the app without providing any personal information.

\end{enumerate}

\section{State of Art}
In this section, it will be presented the state of the art in the field of decentralized communication systems.
 The focus will be on the main existing systems, Aggregate Computing frameworks, and lightweight communication protocols.
\subsection{Existing systems}
Several communication technologies and systems have been developed over the years to facilitate decentralized data exchange among devices.
The software that has spread the most and gained significant attention includes: \textit{Briar}, \textit{Bridgefy}, \textit{FireChat}.
\subsubsection{Briar}
\textbf{Briar} \cite{briar} is an open-source \ac{P2P} messaging platform designed for secure,
 resilient communication without centralized servers.
It supports multiple transport methods including Bluetooth, Wi-Fi and Tor, with all communication end-to-end encrypted.
Briar provide a mailbox system \textit{Briar Mailbox} that lets the users receive encrypted messages from their contacts while Briar is offline. Next time Briar comes online it will automatically fetch the messages from the Mailbox.
The primary target audience includes activists, journalists, and civil society members who require secure communication in restricted or infrastructure-limited environments.

A notable feature is the ability to install Briar on an Android device directly from another device that already has it installed, facilitating deployment in disconnected scenarios.
Nowadays the application is available only for Android devices, with no official iOS version.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/briar.png}}
    \caption{Diagram illustrating how Briar supports private messaging, public forums, and blogs through multiple transport methods such as Bluetooth, Wi-Fi, and the Internet. \protect\cite{briar}.}
    \label{fig:briar-architecture}
\end{figure}

\subsubsection{Bridgefy}
\textbf{Bridgefy} \cite{bridgefy} is a mobile messaging application that enables offline communication through Bluetooth mesh networking technology.

The platform allows smartphones to connect directly with nearby devices, creating a decentralized mesh network that can relay messages across multiple hops without requiring Internet connectivity.
Originally designed for emergency situations and large gatherings where cellular networks become congested, Bridgefy has been deployed in various crisis scenarios including natural disasters and political protests.

Messages are automatically routed through intermediate devices, extending the effective communication range beyond direct Bluetooth connectivity (typically 100 meters).
Bridgefy uses encryption protocols to secure message transmission; this capability was not available in the app's initial versions.

The service operates on both Android and iOS devices, with a user-friendly interface designed for rapid adoption during emergency situations.
One limitation is the reliance on device density: the mesh network requires sufficient nearby users to establish reliable multi-hop communication paths.


\subsubsection{FireChat}
\textbf{Firechat} was the first popular example of a messaging application that used mesh network topology to communicate between users.

\cite{7937749} FireChat relays messages from one device to another through each user's WiFi or Bluetooth radios, thereby creating a “mesh” of phones receiving and relaying messages even when each message is not viewable on every device (\Cref{fig:firechat-architecture}).
 This method of communication eliminates the need for centralized communication channels such as cellphone towers that every transmission must pass through.
While this system is beneficial in overcrowded networks, it eliminates the possibility of controlling or monitoring the network at one point.

Although not originally intended for this purpose, FireChat was widely adopted during civil protests.
 The application gained popularity in Iraq in 2014, when government restrictions limited Internet access, and later during the 2014 Hong Kong protests (known as the Umbrella Revolution)

Nowadays Firechat is discontinued and no longer available on app stores, the official website is also offline.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/bluetooth-mesh.png}}
    \caption{FireChat's mesh networking architecture, where messages are relayed through nearby devices using WiFi and Bluetooth, enabling communication without centralized infrastructure.}
    \label{fig:firechat-architecture}
\end{figure}

\subsubsection{Final considerations} Those three illustrated applications have more or less the same purpose of providing a decentralized approach to messaging.
\textit{Briar} stands out for its strong emphasis on security and privacy, making it suitable for users in sensitive situations. 
\textit{Bridgefy} is the most user-friendly and practical, focused on connecting users in emergency scenarios; encryption was included in later versions.
\textit{FireChat} was the pioneering first popular example, but now outdated and discontinued. It inspired newer applications.

These applications demonstrate the feasibility of decentralized communication, they rely on predefined routing or broadcasting protocols.
 None of them incorporate \textit{spatial awareness} or \textit{self-organizing behavior}, features that are naturally modeled through \textit{Aggregate Computing}.

\subsection{Aggregate Computing frameworks}
There are several frameworks and libraries that facilitate the development of Aggregate Computing applications, 
implementing the principles of field calculus and providing abstractions for defining collective behaviors.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/scafi.png}}
    \caption{High-level architecture of the ScaFi framework, illustrating its components ~\protect\cite{CASADEI2022101248}.}
    \label{fig:scafi-architecture}
\end{figure}
Some of the most notable ones include:
\begin{itemize}
    \item \textbf{ScaFi} (Scala Field) is a framework written in Scala for Aggregate Computing \cite{CASADEI2022101248}. 
    It provides a \ac{DSL} and API modules for writing, testing, and running aggregate programs, the high-level architecture of ScaFi is depicted in \Cref{fig:scafi-architecture}.
    \textit{ScaFi} also includes a simulation environment with a \ac{GUI}, integrated with the Alchemist simulator \cite{10.1007/978-3-030-78198-9_10}.
    
    The main applications are in the development of swarm systems, crowd management, wireless sensor network and
    smart city applications.

    \textit{ScaFi} only supports JVM and web-based applications.
    \item \textbf{Protelis} \cite{10.1145/2695664.2695913} is a programming language designed to simplify the development of resilient and well-structured networked systems, and can be integrated into various simulation frameworks. 
    It provides a Java-hosted implementation of the field calculus through the \texttt{protelis-lang} library, offering a domain-general foundational API for Aggregate Programming \cite{8064092}.
    \begin{figure}
        \centering
        \fbox{\includegraphics[width=.8\linewidth]{figures/protelis.png}}
        \caption{Protelis architecture.}
        \label{fig:protelis-architecture}
    \end{figure}
    The Protelis architecture (\Cref{fig:protelis-architecture}) relies on an interpreter that periodically executes pre-parsed aggregate programs, enabling communication among devices and interaction with the environment.
    However, since it is built on the Xtext framework for domain-specific languages and requires a JVM to run, its deployment is limited to Java-compatible devices, reducing platform heterogeneity.

\end{itemize}

\subsection{Lightweight communication protocols}
In the context of decentralized and distributed messaging systems, \textbf{lightweight communication protocols} are essential for efficient data exchange among devices with limited resources.
A lightweight protocol minimizes overhead transmitted on top of the functional data, useful in scenarios where bandwidth, power, or processing capacity is limited.
With the proliferation of \ac{IoT} and mobile devices, these protocols have become crucial in modern networking.

Keeping in mind the distributed nature of the system, we can consider the following technologies.

\textbf{\ac{BLE}} formerly marked as \textit{Bluetooth Smart}, is a wireless \ac{PAN} technology designed for short-range communication with low power consumption.
\ac{BLE} uses the same 2.4 GHz radio frequency as classic Bluetooth but employs a different protocol stack optimized for energy usage.
It has no compatibility with classic Bluetooth, meaning that devices supporting only one of the two standards cannot communicate directly.

\ac{BLE} supports device discovery and connection through low-duty advertising and scanning cycles, enabling the creation of ad-hoc networks for proximity-based communication.

Another similar protocol is \textbf{Wi-Fi Direct}, a wireless standard that enables devices to connect directly (using Wi-Fi) to each other without the need for a traditional access point or router.
It allows \ac{P2P} communication using standard Wi-Fi technology, offering higher data transfer rates and longer range compared to Bluetooth-based solutions.
\begin{table}[h!]
\centering
\caption{Comparison between \ac{BLE} and Wi-Fi Direct.}
\label{tab:ble-wifidirect}
\begin{tabular}{p{4cm}p{5cm}p{5cm}}
\toprule
\textbf{Feature} & \textbf{\ac{BLE}} & \textbf{Wi-Fi Direct} \\ 
\midrule

\textbf{Communication range} & Typically up to 50 meters (depending on environment) & Up to 200 meters (depending on device and power) \\[4pt]
\midrule

\textbf{Data rate} & Up to 2 Mbps (BLE 5.0) & Up to 250 Mbps \\[4pt]
\midrule

\textbf{Consumption} & Very low, optimized for battery-powered devices & Higher, comparable to standard Wi-Fi \\[4pt]
\midrule

\textbf{Network topology} & Simple connections or small mesh networks & Group-based topology with a dynamically assigned group owner \\[4pt]
\midrule

\textbf{Connection setup} & Fast, lightweight pairing through advertising and scanning & Slower setup, requires negotiation between devices \\[4pt]
\midrule

\textbf{Use cases} & Sensor networks, wearables, proximity-based messaging & File sharing, multimedia streaming, ad-hoc data exchange \\[4pt]
\midrule

\textbf{Advantages} & Energy efficient, widely supported, ideal for IoT & High throughput, longer range, infrastructure-free \\[4pt]
\midrule

\textbf{Limitations} & Limited bandwidth and range & Higher energy consumption, more complex setup \\
\bottomrule
\end{tabular}
\end{table}

The table \Cref{tab:ble-wifidirect} summarizes the main differences between \ac{BLE} and Wi-Fi Direct.

\subsubsection{\ac{MQTT}}
\label{subsubsection:Mqtt}
On the other hand, \textbf{\ac{MQTT}} relies on a central broker to manage message distribution.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/mqtt.png}}
    \caption{MQTT architecture, illustrating the publish-subscribe model with clients and a central broker.}
    \label{fig:mqtt-architecture}
\end{figure}
It follows a publish-subscribe model (\Cref{fig:mqtt-architecture}) where the centralized server known as Broker is connected to various devices which are Clients \cite{usmani2021mqtt}.
The latter publish messages to specific topics, while subscribers receive only the data relevant to them.

\ac{MQTT} is widely used in \ac{IoT} systems due to its lightweight nature and efficient use of bandwidth.

In the current implementation of the proposed application \ref{goal:application}, \ac{MQTT} is employed as the communication layer to handle messages across devices. 
Although it relies on a central broker and is therefore not fully decentralized, its advantages make it suitable for prototyping and testing the distributed algorithm \ref{goal:algorithm}. 
Future developments may involve replacing \ac{MQTT} with \ac{P2P} technologies such as Bluetooth, to achieve complete decentralization.


\chapter{Architecture and Implementation}

\section{Requirements}
This section outlines both the functional and non-functional requirements of the messaging system developed in this thesis.
It describes what the system is expected to accomplish, its qualities, constraints, and performances.

The requirements refer to both the messaging algorithm itself (see \ref{goal:algorithm}) and the mobile application (see \ref{goal:application}).
\subsection{Functional requirements}
The functional requirements define the features, behaviors, and operations that the messaging system must support.
\subsubsection{Aggregate Computing algorithm}
\label{subsection:requirements-algorithm}
The messaging algorithm represents the Aggregate Computing layer, the core logic of the system.
\begin{enumerate}
    \item \textbf{Message propagation}: The algorithm must enable nodes to create and send messages to other nodes within the network. 
    \item \textbf{Decentralized and proximity-based communication}: Each node should be able to communicate only with its immediate neighbors, the message is propagated in the network through local interactions.
    There is no central authority managing the communication, the system must be fully distributed and autonomous.
    \item \textbf{Parameter configurability}: The algorithm should allow message sources to define the expiration time of the message and the maximum propagation distance. 
    With these parameters it is possible to control how long a message remains valid and how far it can spread in the network, limiting unnecessary communication overhead.
    \item \textbf{Dynamic topology handling}: The network topology can change dynamically, with nodes joining or leaving the network at any time. 
    The algorithm must be robust and adaptable to these changes, ensuring continuous message propagation without disruptions.
    \item \textbf{Simulation support}: The algorithm must be executable within a simulated environment to facilitate testing and validation.
     This approach enables controlled experimentation under various network conditions and scenarios, ensuring the correctness and stability of the algorithm before its deployment on real devices.
\end{enumerate}

\subsubsection{Mobile Application}
The mobile application serves as the \ac{UI} for the messaging system, providing users both an interface and a runtime environment for the algorithm.
\begin{enumerate}
    \item \textbf{Cross-platform compatibility}: The application must be supported on both Android and iOS platforms.
    \item \textbf{User interface}: The application should provide a simple and intuitive \ac{UI} that allows users to compose messages, set parameters (expiration time and propagation distance), and view received messages in real-time.
    \item \textbf{GPS integration}: The application uses the device's GPS to determine its location, which is essential to compute distances between nodes for message propagation. 
    \item \textbf{Communication layer}: A lightweight communication protocol must be used to send messages between the various nodes in the network.

\end{enumerate}

\subsection{Non-functional requirements}
The non-functional requirements specify the quality attributes, constraints, and performance criteria that the messaging system must meet,
defining how well the functions should be performed.

One of the main non-functional requirements of the system is the \textbf{code alignment} between the simulator
and the mobile application.
This ensures that the same algorithmic logic is shared across both environments, minimizing discrepancies between
simulation and real-world execution.
In practice, the aggregate algorithm is implemented as a common API, which can be invoked identically within the
simulation framework and the mobile runtime.
This alignment is fundamental, as the distributed nature of the system requires extensive validation under multiple-node scenarios.

Another key non-functional requirement is \textbf{scalability}.
The system must sustain acceptable performance levels as the number of participating nodes increases, ensuring that the aggregate computation cycle executes periodically without noticeable degradation on mobile devices. 

In addition, the codebase must exhibit high \textbf{maintainability} and \textbf{extensibility}, enabling future developers to easily understand, modify, and enhance the system. These qualities are achieved through modular architectural design, comprehensive documentation, and adherence to established coding standards. Furthermore, the system architecture should be flexible enough to support the integration of new communication protocols or additional functionalities without requiring significant refactoring.


\subsection{Analysis}
To address these requirements and challenges, the system adopts a \textbf{decentralized architecture} through the principles of \textbf{Aggregate Computing}. 
Each device is treated as an independent computational entity (or node) capable of locally executing aggregate functions and exchanging information only with its neighbors. 
This model allows global behaviors, such as message diffusion or decay, to emerge from simple local interactions. 
Message propagation is achieved through \textbf{gradient algorithm} based on \textbf{gossip}, which naturally reflect spatial proximity and temporal dynamics within the network.

From an implementation perspective, the \textit{Collektive} framework is employed to define and simulate the aggregate behavior of the system, ensuring correctness and reproducibility under controlled conditions. 

The communication layer is currently based on the \textbf{\ac{MQTT}} protocol, which provides a lightweight and reliable publish/subscribe mechanism suitable for distributed messaging and initial prototyping. 

Finally, the use of \textbf{\ac{KMP}} enables a unified codebase that targets multiple platforms (Android, iOS, JVM) facilitating consistency between the simulated and real execution environments.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/layered-design.png}}
    \caption{High-level overview of the architecture, illustrating the interaction between the different layers of the messaging system.}
    \label{fig:architecture-overview}
\end{figure}

\section{Network Architecture}
In the following sections, the overall \textbf{architecture} of the messaging system will be described, focusing on both the design and communication model.
\subsection{Design}
The network is modeled as an undirected graph $G = (V, E)$, where $V$ is the set of nodes representing individual devices, and $E$ is the set of edges representing communication links between neighboring nodes (\Cref{fig:network-graph}).
\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.6\linewidth]{figures/network-graph.png}}
    \caption{Network architecture image taken from \textit{Alchemist Simulator} illustrating nodes and their communication links. Each node represents a device in the messaging system, and edges denote proximity-based connections enabling message exchange.}
    \label{fig:network-graph}
\end{figure}

A \textbf{node} in the network represents a single device (e.g., a smartphone) running the messaging software.
Each node exhibits the following characteristics:
\begin{enumerate}
\item \textbf{Lifecycle}: The lifecycle of a node begins when it joins the network and discovers its neighboring devices. 
While active, the node periodically executes the aggregate algorithm through computation cycles. 
When the node leaves the network (for example, when the application is closed), it terminates all communication and computation activities.
\item \textbf{State}: Each node maintains a local state that includes its unique identifier, 
a list of neighboring nodes with associated distances, its current message value, and positional information. This state is continuously updated based on local interactions.
\item \textbf{Internal Aggregate Computing Logic}: Each node autonomously executes the aggregate algorithm defined in Section~\ref{goal:algorithm}, which governs how messages are generated, propagated, and expired according to proximity-based interactions with neighboring nodes.
\end{enumerate}
The network is \textbf{distributed} and \textbf{decentralized}, meaning there is no central authority or server managing the communication.
All the nodes behave like whole systems, they are considered together as a single entity like a computational field, not as a collection of individual devices.
This is achieved through local interactions, each node independently maintains its state and exchanges information with nearby peers, supporting self-organization and resilience.

This type of network is particulary suitable for \textbf{dynamic} and \textbf{scalable} environments by design, since computation and communication depend only on local interactions and nodes can 
join or leave the network seamlessly, without any disruption. 


\subsection{Communication Model}
\textbf{TODO: Describe the communication model in detail.}
% Expiration time (TTL - Time To Live), Maximum propagation distance (spatial limit), Describe how nodes discover their neighbors
% The system currently employs the \textbf{\ac{MQTT}} protocol as the transport layer to facilitate message exchange among nodes.


\section{Technologies}
\subsubsection{Kotlin Multiplatform}
\textbf{\ac{KMP}} is the programming framework adopted for both the implementation of the messaging algorithm and the development of the mobile application. 

Kotlin is a modern, statically typed, cross-platform programming language that supports type inference and emphasizes conciseness, safety, and interoperability. 
It is fully compatible with Java, as the JVM version of its standard library relies on the Java Class Library, enabling seamless integration with existing Java ecosystems.

The primary goal of Kotlin Multiplatform is to streamline the development of cross-platform applications 
by allowing developers to share common code across multiple targets (such as Android, iOS, JVM, and Web) while maintaining platform-specific implementations only where necessary. 
This approach greatly reduces code duplication, accelerates development cycles, and ensures consistency across different environments.

In this project, KMP enables the reuse of the same aggregate computing logic and communication components across both the simulation and mobile application. 
Compilation targets are defined within the Gradle build configuration, which automates the generation of platform-specific binaries from the shared codebase.


\subsubsection{Collektive}
\textbf{Collektive} is used as Aggregate Computing framework to implement the messaging algorithm (see \Cref{section:Collektive}).

\subsubsection{Compose Multiplatform}
\textbf{Compose Multiplatform} is the UI framework used to implement the \ac{GUI} of the application on both Android and iOS. 
It is based on \textit{\ac{JC}}, Google’s declarative toolkit for building native Android interfaces, and extends its capabilities to multiple platforms through the \ac{KMP} ecosystem.

Compose Multiplatform enables developers to define a single, shared user interface in Kotlin, which is then rendered natively on each target platform. 
This approach allows the same declarative UI components and logic to be reused across environments, 
ensuring a consistent design and behavior while maintaining native performance and responsiveness.

In this project, Compose Multiplatform has been adopted to design the messaging application’s \ac{GUI}, allowing users to create, send, and visualize
messages within a unified layout. 
By sharing the same UI code between Android and iOS, the development process is simplified, reducing maintenance overhead and ensuring visual consistency across platforms.


\subsubsection{Gradle}
\textbf{Gradle} is a powerful build automation and dependency management system widely used in modern software development, particularly for projects based on Java, Kotlin, and Groovy. 
It is designed for flexibility, scalability, and efficiency, making it one of the most popular tools for managing complex, multi-module applications. 
Gradle employs a declarative \ac{DSL}, written in either Groovy or Kotlin, to define build scripts that specify project configurations, dependencies, tasks, and plugins in a concise and human-readable format.

The build process in Gradle is organized around \textit{tasks}, which represent individual units of work, such as compiling source code, running tests, packaging applications, or generating documentation. 
Developers can define custom tasks and establish dependencies among them, allowing precise control over the execution order and workflow of the build process. 
Gradle also supports parallel task execution and incremental builds, improving efficiency and reducing build times.

In the context of this project, Gradle is used to configure the Kotlin Multiplatform environment, manage platform-specific dependencies, and generate binaries for multiple targets, including Android, JVM, and iOS. 
Its integration with the Kotlin DSL ensures a consistent and automated build process across all platforms, simplifying development and maintaining reproducibility across simulation and deployment environments.

\subsubsection{\ac{MQTT}}
\textbf{\ac{MQTT}} protocol is used as the communication layer to send messages between the various nodes in the distributed network (see \Cref{subsubsection:Mqtt}).

\section{Messaging with Aggregate Computing}
The core logic of the messaging system is implemented using the \textit{Collektive} framework, which provides the necessary abstractions and tools to define aggregate behaviors.

% The algorithm that underpins it is designed to respect the requirements outlined in \Cref{subsection:requirements-algorithm}.
In this section it will be described the algorithm that underpins the system and how it meets the requirements outlined in \Cref{subsection:requirements-algorithm}.

\subsection{Gossip behaviour}
\textbf{Gossip protocols}, also known as \textbf{epidemic protocols}, are a class of communication algorithms inspired by the way information spreads in social or biological systems. 
They have emerged as a key communication paradigm for large-scale distributed systems due to their simplicity, scalability, and resilience.

In these protocols, each node periodically contacts one or a few other nodes and exchanges information with them.
The dynamics of information propagation closely resemble the spread of an epidemic, leading to high fault tolerance and self-stabilization.
The guarantees obtained from gossip-based communication are inherently probabilistic: such systems achieve high stability under stress and disruption, while scaling gracefully to a very large number of nodes \cite{1238221}.

In the context of \textit{Aggregate Computing}, computation focuses on collective behaviours that emerge from local interactions.
Each node executes the same local program and exchanges data with its neighbors to collectively produce a global pattern (e.g., diffusion, consensus, or gradient formation).
In this sense, \textit{gossip} acts as a mechanism of information diffusion, where nodes iteratively mix their local states with those of their neighbors to approximate global aggregates.

The algorithm developed in this thesis follows a similar \textbf{gossip behaviour}, where information spreads through local \ac{P2P} interactions to collectively achieve a consistent global state in a decentralized and self-stabilizing manner.

\subsubsection{Diffusion speed}
As defined in \cite{1238221}, the \textbf{diffusion speed} of gossip protocols represents the rate
at which information originating from any node spreads and becomes uniformly mixed throughout a distributed network.
It quantifies how quickly local data diffuses across nodes through randomized peer-to-peer exchanges.

Formally, the diffusion speed $\boldsymbol{T(\delta, n, \epsilon)}$
is defined as the smallest number of rounds required for all (n) nodes’ estimates to deviate from the global average by at most a relative error $\epsilon$, with probability at least $1 - \delta$.
This metric provides a unified way to reason about the convergence rate of gossip-based communication mechanisms, regardless of the specific network topology.

In the case of \textbf{Uniform Gossip}, where each node randomly selects a neighbor to exchange information with in each round, 
diffusion occurs exponentially fast, with a time complexity of:
\begin{equation}
T(\delta, n, \epsilon) = O(\log(n) + \log(1/\epsilon) + \log(1/\delta))
\end{equation}

demonstrating that even simple randomized communication mechanisms can achieve rapid and robust global convergence.


\subsection{Gradient algorithm}
The purpose of this algorithm is to enable communication between nodes finding the shortest path to a message source.
The algorithm computes, in a fully distributed manner, the minimum distance (\textbf{gradient}) from each node to a designated target (the source that sends the message).
Full algorithm code is reported in \Cref{lst:algorithm-code}.
\lstinputlisting[float,language=Kotlin,label={lst:algorithm-code}, caption={Entire algorithm code}]{listings/algorithm.kt}


This is a \textbf{Bellman-Ford} style algorithm, applied over the network graph:
\begin{itemize}
    \item \textbf{Graph} $\rightarrow$ undirected weighed graph $G = (V, E)$ where $V$ is the set of nodes and $E$ is the set of edges.
    \item \textbf{Nodes} $\rightarrow$ each node $u \in V$ represents a device in the network.
    \item \textbf{Weights} $\rightarrow$ each edge $(u, v) \in E$ has an associated weight $w(u, v)$ representing the distance between nodes $u$ and $v$.
    \item \textbf{Relaxation} $\rightarrow$ the algorithm iteratively updates the estimated distances to each node by considering all edges and their weights, gradually converging to the shortest path.
\end{itemize}


\subsubsection{Initialization}
The algorithm starts by initializing the nodes. 
Each node first of all checks if it is the source node (the one that created the message).
If it is, it sets its distance to zero and prepares the message content, 
otherwise it initializes its distance to infinity indicating that it has not yet received the message (\Cref{lst:initialization-code}).

\lstinputlisting[language=Kotlin,label={lst:initialization-code}, caption={Initialization code}]{listings/initialization.kt}

Using data class \texttt{GossipGradient} (\Cref{lst:gossip-gradient-dataclass-code}) to keep track of the current path the message has taken from the origin to the current node with the estimated distance.



\lstinputlisting[float, language=Kotlin,label={lst:gossip-gradient-dataclass-code}, caption={Data structure representing a state in a gossip-based gradient algorithm.}]{listings/GossipGradient.kt}
Each node starts with \texttt{path = listOf(localId)} because the path stored in a node’s gossip ends with that node’s ID and 
for every round a neighbor copies your path and then calls \texttt{addHop} to add its own ID to the path, so the invariant stays true.

\subsubsection{Sharing logic and distance computation}
Message dissemination across the network is achieved using Collektive’s \texttt{share} function, which enables efficient, stateful data sharing among neighboring nodes.

At each computational round $k$, every node $u$ reads the gossip messages shared by its neighbors (\texttt{neighborsGossip}) and updates its local state accordingly. Based on this information, the node applies a relaxation step to compute the minimum distance to the message source. For each neighbor $v \in \texttt{neighbors}(u)$, the relaxation is defined as:
\begin{equation}
\boldsymbol{d_{u}^{k+1} = \min(d_{u}^{k},\ d_{v}^{k} + w(v, u))}
\end{equation}
where $w(v, u)$ represents the communication cost or weight of the edge between nodes $v$ and $u$. This iterative process propagates distance information throughout the network, allowing each node to estimate its proximity to the source node (\Cref{lst:relaxation-code}).

\lstinputlisting[language=Kotlin,label={lst:relaxation-code}, caption={Relaxation code to compute the minimum distance from each node to the source.}]{listings/relaxation.kt}

This approach is also safe for non-source nodes, which initially have an empty \texttt{content} 
field and an infinite \texttt{distance}. 

As a result, their state is not propagated to other nodes, since the condition \texttt{neighborGossip.content.isNotEmpty()} and the relaxation step prevent the adoption of invalid or uninitialized data. 
These nodes remain inactive until they receive and relay a valid message proposal, at which point their state becomes part of the propagation process.

\subsubsection{Loop avoidance}
The \texttt{path} field contained in the \texttt{GossipGradient} data class is also used to prevent cycles during message propagation (\Cref{lst:loop-avoidance-code}).

To achieve this, a copy of each neighbor’s path is created, excluding the neighbor’s own identifier. This produces a sequence representing all the hops that precede that neighbor in the propagation chain.

Two checks are then performed to detect and reject cyclic paths. The first condition, \texttt{it == localId}, prevents self-cycles by discarding any proposal that has already passed through the current node. The second, \texttt{it in neighbors}, filters out proposals that traverse any of the current node’s neighbors other than the one under consideration, thereby avoiding “ping-pong” exchanges between adjacent nodes.

Together, these checks ensure that message propagation remains acyclic, improving the efficiency and correctness of the gossip process.

\lstinputlisting[language=Kotlin,label={lst:loop-avoidance-code}, caption={Loop avoidance code preventing cycles during message propagation.}]{listings/loopAvoidance.kt}

\subsubsection{Message expiration and spatial limits}
To regulate both the lifespan and spatial reach of messages within the network, 
the algorithm takes as input two key parameters: the \ac{TTL} (\texttt{lifeTime}) and the maximum propagation distance (\texttt{maxDistance}).
Before forwarding a message, each node applies a filtering step to ensure that only valid messages, those that have not expired and remain within the defined spatial range, are relayed to neighboring nodes (\Cref{lst:expiration-code}).

\lstinputlisting[language=Kotlin,label={lst:expiration-code}, caption={Filtering logic enforcing message expiration and spatial propagation limits.}]{listings/filter.kt}
\subsubsection{Multiple sources}
In a large-scale, real-world deployment, it is common for multiple nodes to generate and transmit messages simultaneously. The algorithm is designed to handle this scenario effectively, allowing multiple sources to coexist and propagate their messages independently without interference.

This behavior is achieved by treating each message source as an independent entity, with every node maintaining separate state information for each active message in the network. Initially, a gossip-based self-stabilization step is applied to the set of active sources (\Cref{lst:sources-sharing-code}).

\lstinputlisting[language=Kotlin,label={lst:sources-sharing-code}, caption={Gossip-based self-stabilization of the message sources.}]{listings/sources-sharing.kt}

After stabilization, the gossip-gradient algorithm described previously is executed independently for each source (\Cref{lst:multisources-code}).


Since the implementation relies on the \texttt{share} construct, iterating over all sources requires the use of the \texttt{alignedOn} operator. This operator ensures that only nodes executing the same \texttt{alignedOn(sourceId)} instance exchange values with one another, thereby preventing interference between computations associated with different sources.
\lstinputlisting[language=Kotlin,label={lst:multisources-code}, caption={Execution of the gossip-gradient algorithm for multiple concurrent sources.}]{listings/multipleSources.kt}

\subsubsection{Time complexity}
Let $n = |V|$ be the number of nodes, $m = |E|$ the number of links, and $s$ the number of sources. 
The gradient phase is Bellman–Ford–like with non-negative weights, the pure distance relaxation costs 
$O(nm)$ per source in the worst case (thus $O(n^3)$ on dense graphs with $m \approx n^2$). 

In the implementation presented here, the \textit{loop-avoidance} check scans the neighbor’s path prefix, adding an 
$O(n)$ factor per neighbor. 
This yields $O(mn)$ work per round and up to $O(n)$ rounds, i.e., $O(mn^2)$ per source 
(dense: $O(n^4)$). 

Across $s$ sources, multiply the bounds: $O(snm)$ (dense: $O(sn^3)$) for the pure gradient, 
or $O(smn^2)$ (dense: $O(sn^4)$) with full path checking. 
Bounding the path inspection to a constant $k$ (or removing it) 
recovers the $O(snm)$ worst-case bound.


\section{Mobile Application}

\subsection{User Interface with Compose Multiplatform}

\subsection{Communication layer}


%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------



\backmatter


\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}
