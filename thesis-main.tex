\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acro}

\school{\unibo}
\programme{Corso di Laurea Triennale in Ingegneria e Scienze Informatiche}
\title{Multi-platform distributed systems with aggregate computing in Kotlin: the case of proximity messaging}
\author{Luca Marchi}
\date{\today}
\subject{Programmazione ad Oggetti}
\supervisor{Prof. Pianini Danilo}
\cosupervisor{Dott.ssa Cortecchia Angela}

\session{II}
\academicyear{2024-2025}

\acsetup{first-style=long-short}
\DeclareAcronym{IoT}{
  short = IoT,
  long  = Internet of Things
}
\DeclareAcronym{KMP}{
  short = KMP,
  long  = Kotlin Multiplatform
}
\DeclareAcronym{DSL}{
    short = DSL,
    long  = Domain Specific Language
}

\DeclareAcronym{UI}{
    short = UI,
    long  = User Interface
}


\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	

\end{abstract}

\begin{dedication} % this is optional
To my family.
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------
\section{Context}
In a world where \ac{IoT} devices are becoming increasingly prevalent,
    the need for efficient and reliable communication systems is paramount
    \begin{figure}
        \centering
        \fbox{\includegraphics[width=.8\linewidth]{figures/iot-devices.png}}
        \caption{A variety of \ac{IoT} devices communicating with each other in a real world scenario.}
        \label{fig:iot-devices}
    \end{figure}
    (\Cref{fig:iot-devices}).

    The interactions between neighboring devices play a crucial role in enabling seamless data exchange and coordination,
    so there is the need to design networks with infrastructures that support scalability, adaptability and reusability \cite{beal2015aggregate}.
    In the past, it was reasonable to use a programming model that focused on the
    individual computing device, and its relationship with one or more users.
    However, as systems have grown in scale and complexity with the number of computing devices rising,
    this method has become inadequate.

    Traditional network architectures, rely heavily on centralized
    infrastructures, making them unsuitable for scenarios such as disaster recovery or interactions with neighboring devices.
    The computational model of \textit{aggregate computing} provides a promising
    approach to address these challenges by enabling decentralized and self-organizing systems \cite{viroli2019aggregate}.
    
    Building on this concept, this thesis explores how aggregate programming
    can support a proximity and decentralized messaging system in a network.



\subsection{Aggregate Programming}
\textbf{Aggregate Programming} is a distributed systems paradigm that simplifies programming large networks of devices by focusing on the global, system-level behavior rather than the individual behavior of each device.
It shifts the abstraction to view the network as an aggregate, an agglomeration of nodes that collectively exhibit certain behaviors.
This model is particularly well-suited for scenarios where devices need to coordinate and collaborate based on local interactions, such as in \ac{IoT} applications.

As discussed in distributed field programming \cite{viroli2019aggregate}, there are principles to follow when designing large-scale systems:
\begin{itemize}
    \item The mechanisms ensuring robust coordination should operate transparently in the background, so that programmers don’t need to manage them directly.
    \item The composition of modules and subsystems should be simple and predictable, allowing developers to clearly understand the consequences of combining components.
    \item Large-scale distributed systems often consist of multiple heterogeneous subsystems, each of which may require different coordination strategies depending on the region or context in time.
\end{itemize}
Aggregate programming aims to overcome these challenges through three fundamental principles:
\begin{enumerate}
    \item The computational target is conceived as a region of the environment, with the underlying device-level details abstracted away, potentially even modeled as a continuous spatial domain.
    \item The program logic is expressed as the manipulation of data structures that extend spatially and temporally across that region.
    \item These computations are executed locally by individual devices within the region, which coordinate through resilient mechanisms and proximity-based interactions.
\end{enumerate}
The foundation of this paradigm lies in \textit{field calculus} \cite{beal2015aggregate},
a core set of constructs modeling device behavior and interaction. These essential features are captured
in a tiny universal language suitable for mathematical analysis.
The concept of \textbf{field} plays a central role in this context and originates from physics, where it is defined as a function mapping every point in a space–time domain to a scalar value.

According to \cite{viroli2019aggregate}, the \textit{field value} $\phi$ is a function
\[
\phi : D \rightarrow L
\]
that maps each device $\delta$ in the domain $D$ to a local value $\ell$ in the range $L$.
This value can change in time with a \textit{field evolution} that maps each point in time to a field value.
\Cref{fig:layers-AP} shows how aggregate programming abstracts the complexity of the underlying distributed network and its
 coordination challenges through a sequence of hierarchical abstraction layers.
\begin{figure}
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/layers-AP.png}}
    \caption{Layered structure of aggregate programming, illustrating the abstraction at each level.}
    \label{fig:layers-AP}
\end{figure}

The messaging system developed in this thesis was implemented using \textit{Collektive} \cite{amslaurea31080}, 
an open-source framework designed to simplify the development of distributed systems through the principles of Aggregate Programming. 
Collektive provides developer-facing APIs (as in \Cref{fig:layers-AP}) used to define and execute aggregate applications.
\subsection{Collektive}
Collektive is a framework with the purpose of simplifying the definition of Aggregate Computing systems.
To achieve this, Collektive adopts the Field Calculus model, providing an intuitive way to define aggregate
behavior without low-level coding. Built with \ac{KMP}, it can be executed seamlessly on different targets.
Moreover, a compiler plugin was introduced to support function alignment, automatically annotating aligned functions to ensure consistent coordination among nodes
\cite{amslaurea31080}.

The main features of this framework can be summarized as follows \cite{collektive_docs}:
\begin{itemize}
\item \textbf{High-Level Abstraction}: Collektive streamlines the development of distributed behaviors by enabling developers to define coordination logic succinctly, without explicitly handling individual device states.
\item \textbf{Declarative Programming}: The framework adopts a declarative paradigm, allowing developers to specify the desired system outcomes, while the underlying runtime manages the execution details.
\item \textbf{Dynamic Adaptation}: Applications developed with Collektive can automatically adapt to network variations and external inputs, maintaining robustness in dynamic and unpredictable environments.
\end{itemize}

It provides a minimal \ac{DSL} where the developer can specify the
collective behaviour of a network of devices and the devices can directly communicate with each other and execute the same program.

\section{Motivations}
In this section motivations for implementing a decentralized proximity-based messaging system will be illustrated.

In recent years, the proliferation of \ac{IoT} and mobile devices has increased the need for local communication systems capable of operating even without stable network infrastructure. Centralized architectures, although efficient in connected environments, fail to guarantee reliability and resilience in dynamic or disconnected scenarios.
As devices are becoming pervasive and ubiquitous, new models are required to enable coordination and information exchange without relying on fixed infrastructures.
This need motivates the exploration of decentralized and distributed approaches, which can operate robustly in dynamic and connectivity-limited environments.

% Describe what problem exists and why it’s challenging.
% Focus on the technical or conceptual gap your thesis addresses.

\subsection{Problem statement}
Traditional messaging systems and architectures often rely heavily on centralized servers and infrastructures, which are 
unsuitable and vulnerable for scenarios where connectivity is not guaranteed. 
These situations include \textbf{disaster recovery}, the process for restoring an organization's network infrastructure and operations after a disruptive event, such as a natural disaster, cyberattack, or system failure.

In such environments there are several vulnerabilities and challenges to consider:
\begin{itemize}
    \item \textbf{Single point of failure}: Centralized systems are vulnerable to failures of the authority that makes decisions. This can lead to widespread service disruption and outages.
    \item \textbf{Scalability issues}: As the number of devices increases, centralized systems may struggle to manage the growing volume of data and communication, leading to bottlenecks and delayed responses.
    \item \textbf{Limited resilience}: Centralized architectures often lack the redundancy and fault tolerance needed to maintain functionality in the face of network disruptions or device failures.
\end{itemize}
The networks that need to overcome the issues above can benefit from Aggregate Computing principles, which provides
a distributed architecture where the nodes can directly communicate with the neighbors.

% Give practical examples where your system or research could apply — 
% this grounds your thesis in reality and shows relevance.
\subsection{Real world use cases}
As mentioned in the previous sections, there are several scenarios where a decentralized proximity-based messaging system can be particularly beneficial.

The main use case of such system is in emergency situations. 
When natural disasters, or infrastructure failures occur, cellular networks and Internet connections often go down, making it difficult for people to communicate and coordinate rescue efforts.  
Nearby devices can form ad-hoc Bluetooth or Wi-Fi Direct networks, allowing users in the same area to propagate and share messages without relying on centralized servers.

This architecture can also be useful in large \ac{IoT} networks like sensors systems or drones swarms, operating in remote areas and with the need to communicate without continuous Internet access.

The system's decentralized nature fits perfectly for:
\begin{itemize}
    \item Exchanging local environmental data (temperature, humidity, motion).
    \item Maintaining distributed consensus or context awareness among nearby nodes.
    \item Avoiding single points of failure.
\end{itemize}
A practical example includes a network of environmental sensors deployed in a forest to monitor conditions and detect wildfires (\Cref{fig:use-cases}), or sensors in a smart agriculture field that share humidity data to coordinate irrigation locally.
\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=.8\linewidth]{figures/The-proposed-architecture-for-forest-fire-detection.png}}
    \caption{Real-world use case of a decentralized proximity-based messaging application built on Aggregate Computing principles.
     In this scenario, sensors located near the fire detect the event and propagate an alert message to neighboring nodes within the network. \cite{inproceedings}}
    \label{fig:use-cases}
\end{figure}
% List what your thesis aims to achieve — clearly, concretely, and in your own scope.
% This section connects the problem and use cases to your proposed solution.

\subsection{Goal}
This thesis can be devided into two main goals:
\begin{enumerate}
    \item \textbf{Messaging algorithm}: The first goal is to design and implement a decentralized, proximity-based messaging algorithm grounded in the principles of Aggregate Computing. 
    The network operates in a fully distributed manner, without any central server managing message exchange. 
    Each node acts autonomously, coordinating with its neighbors through local interactions and collectively achieving self-organization, thereby eliminating single points of failure. 
    Communication is proximity-based: devices can only interact with nearby nodes, and messages are propagated progressively across the network, layer by layer. 
    The algorithm must also handle dynamic network topologies, where devices can join or leave the network at any time, ensuring robustness and adaptability. 
    Message sources can define both an expiration time and a maximum propagation distance, enabling controlled diffusion and limiting unnecessary communication overhead. 
    The system is implemented using the \textit{Collektive} framework \cite{amslaurea31080}, leveraging \ac{KMP} to ensure cross-platform compatibility across different targets including 
    JVM, Javascript (browser), Android, iOS, and native versions (for Windows, MacOS, and Linux, both for x86 and ARM CPUs).

    \item \textbf{Mobile application}: The second goal is to develop a multiplatform mobile application using \ac{KMP}. 
    This application leverages the messaging algorithm as a core library to send and receive messages from devices in the network. 
    The app must support both Android and iOS platforms providing a simple, user-friendly interface.
    The \ac{UI} allows users to compose messages, configure parameters (expiration time and propagation distance), and view received messages in real-time.

\end{enumerate}

\section{State of Art}
In this section, it will be presented the state of the art in the field of decentralized communication systems.
 The focus will be on the main existing systems, aggregate computing frameworks, and lightweight P2P protocols.
\subsection{Existing systems}

\subsection{Aggregate computing frameworks}

\subsection{Lightweight P2P protocols}


\chapter{Contribution}

You may also put some code snippet (which is NOT float by default), eg: \cref{lst:random-code}.

\lstinputlisting[float,language=Java,label={lst:random-code}]{listings/HelloWorld.java}

\section{Fancy formulas here}

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter


\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}
